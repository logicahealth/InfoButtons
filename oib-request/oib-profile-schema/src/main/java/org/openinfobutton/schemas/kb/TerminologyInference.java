//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2017.12.05 at 10:31:49 AM MST 
//


package org.openinfobutton.schemas.kb;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import com.kscs.util.jaxb.Buildable;
import com.kscs.util.jaxb.PropertyTree;
import com.kscs.util.jaxb.PropertyTreeUse;


/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType&gt;
 *   &lt;complexContent&gt;
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{}description"/&gt;
 *         &lt;element name="targetCodeSystem" type="{}Id"/&gt;
 *         &lt;element name="codeInference" maxOccurs="unbounded" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="sourceCodeSystem" type="{}Id"/&gt;
 *                   &lt;element name="inferenceDefinition"&gt;
 *                     &lt;complexType&gt;
 *                       &lt;complexContent&gt;
 *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                           &lt;choice&gt;
 *                             &lt;element name="localMappings"&gt;
 *                               &lt;complexType&gt;
 *                                 &lt;complexContent&gt;
 *                                   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                                     &lt;sequence&gt;
 *                                       &lt;element name="mapping" maxOccurs="unbounded"&gt;
 *                                         &lt;complexType&gt;
 *                                           &lt;complexContent&gt;
 *                                             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                                               &lt;attribute name="sourceValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *                                               &lt;attribute name="targetValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *                                               &lt;attribute name="sourceName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *                                               &lt;attribute name="targetName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *                                             &lt;/restriction&gt;
 *                                           &lt;/complexContent&gt;
 *                                         &lt;/complexType&gt;
 *                                       &lt;/element&gt;
 *                                     &lt;/sequence&gt;
 *                                   &lt;/restriction&gt;
 *                                 &lt;/complexContent&gt;
 *                               &lt;/complexType&gt;
 *                             &lt;/element&gt;
 *                             &lt;element name="externalDefinition"&gt;
 *                               &lt;complexType&gt;
 *                                 &lt;complexContent&gt;
 *                                   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                                     &lt;sequence&gt;
 *                                       &lt;element name="traverseAssociation" maxOccurs="unbounded" minOccurs="0"&gt;
 *                                         &lt;complexType&gt;
 *                                           &lt;complexContent&gt;
 *                                             &lt;extension base="{}CD"&gt;
 *                                               &lt;attribute name="sequence" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" /&gt;
 *                                               &lt;attribute name="direction" use="required"&gt;
 *                                                 &lt;simpleType&gt;
 *                                                   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
 *                                                     &lt;enumeration value="DIRECT"/&gt;
 *                                                     &lt;enumeration value="INVERSE"/&gt;
 *                                                   &lt;/restriction&gt;
 *                                                 &lt;/simpleType&gt;
 *                                               &lt;/attribute&gt;
 *                                               &lt;attribute name="maxConcepts" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
 *                                             &lt;/extension&gt;
 *                                           &lt;/complexContent&gt;
 *                                         &lt;/complexType&gt;
 *                                       &lt;/element&gt;
 *                                       &lt;element name="codeProperty" type="{}Id"/&gt;
 *                                       &lt;element name="displayNameProperty" type="{}Id"/&gt;
 *                                     &lt;/sequence&gt;
 *                                   &lt;/restriction&gt;
 *                                 &lt;/complexContent&gt;
 *                               &lt;/complexType&gt;
 *                             &lt;/element&gt;
 *                           &lt;/choice&gt;
 *                         &lt;/restriction&gt;
 *                       &lt;/complexContent&gt;
 *                     &lt;/complexType&gt;
 *                   &lt;/element&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="keywordInference" minOccurs="0"&gt;
 *           &lt;complexType&gt;
 *             &lt;complexContent&gt;
 *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
 *                 &lt;sequence&gt;
 *                   &lt;element name="searchCodeSystem" type="{}Id"/&gt;
 *                   &lt;element name="codeProperty" type="{}Id"/&gt;
 *                   &lt;element name="displayNameProperty" type="{}Id"/&gt;
 *                 &lt;/sequence&gt;
 *               &lt;/restriction&gt;
 *             &lt;/complexContent&gt;
 *           &lt;/complexType&gt;
 *         &lt;/element&gt;
 *         &lt;element name="callInferenceByName" type="{}ST" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/restriction&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "description",
    "targetCodeSystem",
    "codeInference",
    "keywordInference",
    "callInferenceByName"
})
@XmlRootElement(name = "terminologyInference")
public class TerminologyInference {

    @XmlElement(required = true)
    protected String description;
    @XmlElement(required = true)
    protected Id targetCodeSystem;
    protected List<TerminologyInference.CodeInference> codeInference;
    protected TerminologyInference.KeywordInference keywordInference;
    protected String callInferenceByName;

    /**
     * Gets the value of the description property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getDescription() {
        return description;
    }

    /**
     * Sets the value of the description property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setDescription(String value) {
        this.description = value;
    }

    /**
     * Gets the value of the targetCodeSystem property.
     * 
     * @return
     *     possible object is
     *     {@link Id }
     *     
     */
    public Id getTargetCodeSystem() {
        return targetCodeSystem;
    }

    /**
     * Sets the value of the targetCodeSystem property.
     * 
     * @param value
     *     allowed object is
     *     {@link Id }
     *     
     */
    public void setTargetCodeSystem(Id value) {
        this.targetCodeSystem = value;
    }

    /**
     * Gets the value of the codeInference property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the codeInference property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getCodeInference().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TerminologyInference.CodeInference }
     * 
     * 
     */
    public List<TerminologyInference.CodeInference> getCodeInference() {
        if (codeInference == null) {
            codeInference = new ArrayList<TerminologyInference.CodeInference>();
        }
        return this.codeInference;
    }

    /**
     * Gets the value of the keywordInference property.
     * 
     * @return
     *     possible object is
     *     {@link TerminologyInference.KeywordInference }
     *     
     */
    public TerminologyInference.KeywordInference getKeywordInference() {
        return keywordInference;
    }

    /**
     * Sets the value of the keywordInference property.
     * 
     * @param value
     *     allowed object is
     *     {@link TerminologyInference.KeywordInference }
     *     
     */
    public void setKeywordInference(TerminologyInference.KeywordInference value) {
        this.keywordInference = value;
    }

    /**
     * Gets the value of the callInferenceByName property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getCallInferenceByName() {
        return callInferenceByName;
    }

    /**
     * Sets the value of the callInferenceByName property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setCallInferenceByName(String value) {
        this.callInferenceByName = value;
    }

    /**
     * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
     * 
     * @param _other
     *     A builder instance to which the state of this object will be copied.
     */
    public<_B >void copyTo(final TerminologyInference.Builder<_B> _other) {
        _other.description = this.description;
        _other.targetCodeSystem = ((this.targetCodeSystem == null)?null:this.targetCodeSystem.newCopyBuilder(_other));
        if (this.codeInference == null) {
            _other.codeInference = null;
        } else {
            _other.codeInference = new ArrayList<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>>();
            for (TerminologyInference.CodeInference _item: this.codeInference) {
                _other.codeInference.add(((_item == null)?null:_item.newCopyBuilder(_other)));
            }
        }
        _other.keywordInference = ((this.keywordInference == null)?null:this.keywordInference.newCopyBuilder(_other));
        _other.callInferenceByName = this.callInferenceByName;
    }

    public<_B >TerminologyInference.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
        return new TerminologyInference.Builder<_B>(_parentBuilder, this, true);
    }

    public TerminologyInference.Builder<Void> newCopyBuilder() {
        return newCopyBuilder(null);
    }

    public static TerminologyInference.Builder<Void> builder() {
        return new TerminologyInference.Builder<Void>(null, null, false);
    }

    public static<_B >TerminologyInference.Builder<_B> copyOf(final TerminologyInference _other) {
        final TerminologyInference.Builder<_B> _newBuilder = new TerminologyInference.Builder<_B>(null, null, false);
        _other.copyTo(_newBuilder);
        return _newBuilder;
    }

    /**
     * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
     * 
     * @param _other
     *     A builder instance to which the state of this object will be copied.
     */
    public<_B >void copyTo(final TerminologyInference.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
        final PropertyTree descriptionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("description"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(descriptionPropertyTree!= null):((descriptionPropertyTree == null)||(!descriptionPropertyTree.isLeaf())))) {
            _other.description = this.description;
        }
        final PropertyTree targetCodeSystemPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("targetCodeSystem"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(targetCodeSystemPropertyTree!= null):((targetCodeSystemPropertyTree == null)||(!targetCodeSystemPropertyTree.isLeaf())))) {
            _other.targetCodeSystem = ((this.targetCodeSystem == null)?null:this.targetCodeSystem.newCopyBuilder(_other, targetCodeSystemPropertyTree, _propertyTreeUse));
        }
        final PropertyTree codeInferencePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("codeInference"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(codeInferencePropertyTree!= null):((codeInferencePropertyTree == null)||(!codeInferencePropertyTree.isLeaf())))) {
            if (this.codeInference == null) {
                _other.codeInference = null;
            } else {
                _other.codeInference = new ArrayList<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>>();
                for (TerminologyInference.CodeInference _item: this.codeInference) {
                    _other.codeInference.add(((_item == null)?null:_item.newCopyBuilder(_other, codeInferencePropertyTree, _propertyTreeUse)));
                }
            }
        }
        final PropertyTree keywordInferencePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("keywordInference"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(keywordInferencePropertyTree!= null):((keywordInferencePropertyTree == null)||(!keywordInferencePropertyTree.isLeaf())))) {
            _other.keywordInference = ((this.keywordInference == null)?null:this.keywordInference.newCopyBuilder(_other, keywordInferencePropertyTree, _propertyTreeUse));
        }
        final PropertyTree callInferenceByNamePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("callInferenceByName"));
        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(callInferenceByNamePropertyTree!= null):((callInferenceByNamePropertyTree == null)||(!callInferenceByNamePropertyTree.isLeaf())))) {
            _other.callInferenceByName = this.callInferenceByName;
        }
    }

    public<_B >TerminologyInference.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
        return new TerminologyInference.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
    }

    public TerminologyInference.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
        return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
    }

    public static<_B >TerminologyInference.Builder<_B> copyOf(final TerminologyInference _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
        final TerminologyInference.Builder<_B> _newBuilder = new TerminologyInference.Builder<_B>(null, null, false);
        _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
        return _newBuilder;
    }

    public static TerminologyInference.Builder<Void> copyExcept(final TerminologyInference _other, final PropertyTree _propertyTree) {
        return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
    }

    public static TerminologyInference.Builder<Void> copyOnly(final TerminologyInference _other, final PropertyTree _propertyTree) {
        return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
    }

    public static class Builder<_B >implements Buildable
    {

        protected final _B _parentBuilder;
        protected final TerminologyInference _storedValue;
        private String description;
        private Id.Builder<TerminologyInference.Builder<_B>> targetCodeSystem;
        private List<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>> codeInference;
        private TerminologyInference.KeywordInference.Builder<TerminologyInference.Builder<_B>> keywordInference;
        private String callInferenceByName;

        public Builder(final _B _parentBuilder, final TerminologyInference _other, final boolean _copy) {
            this._parentBuilder = _parentBuilder;
            if (_other!= null) {
                if (_copy) {
                    _storedValue = null;
                    this.description = _other.description;
                    this.targetCodeSystem = ((_other.targetCodeSystem == null)?null:_other.targetCodeSystem.newCopyBuilder(this));
                    if (_other.codeInference == null) {
                        this.codeInference = null;
                    } else {
                        this.codeInference = new ArrayList<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>>();
                        for (TerminologyInference.CodeInference _item: _other.codeInference) {
                            this.codeInference.add(((_item == null)?null:_item.newCopyBuilder(this)));
                        }
                    }
                    this.keywordInference = ((_other.keywordInference == null)?null:_other.keywordInference.newCopyBuilder(this));
                    this.callInferenceByName = _other.callInferenceByName;
                } else {
                    _storedValue = _other;
                }
            } else {
                _storedValue = null;
            }
        }

        public Builder(final _B _parentBuilder, final TerminologyInference _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            this._parentBuilder = _parentBuilder;
            if (_other!= null) {
                if (_copy) {
                    _storedValue = null;
                    final PropertyTree descriptionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("description"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(descriptionPropertyTree!= null):((descriptionPropertyTree == null)||(!descriptionPropertyTree.isLeaf())))) {
                        this.description = _other.description;
                    }
                    final PropertyTree targetCodeSystemPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("targetCodeSystem"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(targetCodeSystemPropertyTree!= null):((targetCodeSystemPropertyTree == null)||(!targetCodeSystemPropertyTree.isLeaf())))) {
                        this.targetCodeSystem = ((_other.targetCodeSystem == null)?null:_other.targetCodeSystem.newCopyBuilder(this, targetCodeSystemPropertyTree, _propertyTreeUse));
                    }
                    final PropertyTree codeInferencePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("codeInference"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(codeInferencePropertyTree!= null):((codeInferencePropertyTree == null)||(!codeInferencePropertyTree.isLeaf())))) {
                        if (_other.codeInference == null) {
                            this.codeInference = null;
                        } else {
                            this.codeInference = new ArrayList<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>>();
                            for (TerminologyInference.CodeInference _item: _other.codeInference) {
                                this.codeInference.add(((_item == null)?null:_item.newCopyBuilder(this, codeInferencePropertyTree, _propertyTreeUse)));
                            }
                        }
                    }
                    final PropertyTree keywordInferencePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("keywordInference"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(keywordInferencePropertyTree!= null):((keywordInferencePropertyTree == null)||(!keywordInferencePropertyTree.isLeaf())))) {
                        this.keywordInference = ((_other.keywordInference == null)?null:_other.keywordInference.newCopyBuilder(this, keywordInferencePropertyTree, _propertyTreeUse));
                    }
                    final PropertyTree callInferenceByNamePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("callInferenceByName"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(callInferenceByNamePropertyTree!= null):((callInferenceByNamePropertyTree == null)||(!callInferenceByNamePropertyTree.isLeaf())))) {
                        this.callInferenceByName = _other.callInferenceByName;
                    }
                } else {
                    _storedValue = _other;
                }
            } else {
                _storedValue = null;
            }
        }

        public _B end() {
            return this._parentBuilder;
        }

        protected<_P extends TerminologyInference >_P init(final _P _product) {
            _product.description = this.description;
            _product.targetCodeSystem = ((this.targetCodeSystem == null)?null:this.targetCodeSystem.build());
            if (this.codeInference!= null) {
                final List<TerminologyInference.CodeInference> codeInference = new ArrayList<TerminologyInference.CodeInference>(this.codeInference.size());
                for (TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>> _item: this.codeInference) {
                    codeInference.add(_item.build());
                }
                _product.codeInference = codeInference;
            }
            _product.keywordInference = ((this.keywordInference == null)?null:this.keywordInference.build());
            _product.callInferenceByName = this.callInferenceByName;
            return _product;
        }

        /**
         * Sets the new value of "description" (any previous value will be replaced)
         * 
         * @param description
         *     New value of the "description" property.
         */
        public TerminologyInference.Builder<_B> withDescription(final String description) {
            this.description = description;
            return this;
        }

        /**
         * Sets the new value of "targetCodeSystem" (any previous value will be replaced)
         * 
         * @param targetCodeSystem
         *     New value of the "targetCodeSystem" property.
         */
        public TerminologyInference.Builder<_B> withTargetCodeSystem(final Id targetCodeSystem) {
            this.targetCodeSystem = ((targetCodeSystem == null)?null:new Id.Builder<TerminologyInference.Builder<_B>>(this, targetCodeSystem, false));
            return this;
        }

        /**
         * Returns a new builder to build the value of the "targetCodeSystem" property (replacing previous value).
         * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
         * 
         * @return
         *     A new builder to build the value of the "targetCodeSystem" property.
         *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
         */
        public Id.Builder<? extends TerminologyInference.Builder<_B>> withTargetCodeSystem() {
            return this.targetCodeSystem = new Id.Builder<TerminologyInference.Builder<_B>>(this, null, false);
        }

        /**
         * Adds the given items to the value of "codeInference"
         * 
         * @param codeInference
         *     Items to add to the value of the "codeInference" property
         */
        public TerminologyInference.Builder<_B> addCodeInference(final Iterable<? extends TerminologyInference.CodeInference> codeInference) {
            if (codeInference!= null) {
                if (this.codeInference == null) {
                    this.codeInference = new ArrayList<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>>();
                }
                for (TerminologyInference.CodeInference _item: codeInference) {
                    this.codeInference.add(new TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>(this, _item, false));
                }
            }
            return this;
        }

        /**
         * Sets the new value of "codeInference" (any previous value will be replaced)
         * 
         * @param codeInference
         *     New value of the "codeInference" property.
         */
        public TerminologyInference.Builder<_B> withCodeInference(final Iterable<? extends TerminologyInference.CodeInference> codeInference) {
            if (this.codeInference!= null) {
                this.codeInference.clear();
            }
            return addCodeInference(codeInference);
        }

        /**
         * Adds the given items to the value of "codeInference"
         * 
         * @param codeInference
         *     Items to add to the value of the "codeInference" property
         */
        public TerminologyInference.Builder<_B> addCodeInference(TerminologyInference.CodeInference... codeInference) {
            addCodeInference(Arrays.asList(codeInference));
            return this;
        }

        /**
         * Sets the new value of "codeInference" (any previous value will be replaced)
         * 
         * @param codeInference
         *     New value of the "codeInference" property.
         */
        public TerminologyInference.Builder<_B> withCodeInference(TerminologyInference.CodeInference... codeInference) {
            withCodeInference(Arrays.asList(codeInference));
            return this;
        }

        /**
         * Returns a new builder to build an additional value of the "CodeInference" property.
         * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.Builder#end()} to return to the current builder.
         * 
         * @return
         *     a new builder to build an additional value of the "CodeInference" property.
         *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.Builder#end()} to return to the current builder.
         */
        public TerminologyInference.CodeInference.Builder<? extends TerminologyInference.Builder<_B>> addCodeInference() {
            if (this.codeInference == null) {
                this.codeInference = new ArrayList<TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>>();
            }
            final TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>> codeInference_Builder = new TerminologyInference.CodeInference.Builder<TerminologyInference.Builder<_B>>(this, null, false);
            this.codeInference.add(codeInference_Builder);
            return codeInference_Builder;
        }

        /**
         * Sets the new value of "keywordInference" (any previous value will be replaced)
         * 
         * @param keywordInference
         *     New value of the "keywordInference" property.
         */
        public TerminologyInference.Builder<_B> withKeywordInference(final TerminologyInference.KeywordInference keywordInference) {
            this.keywordInference = ((keywordInference == null)?null:new TerminologyInference.KeywordInference.Builder<TerminologyInference.Builder<_B>>(this, keywordInference, false));
            return this;
        }

        /**
         * Returns a new builder to build the value of the "keywordInference" property (replacing previous value).
         * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.KeywordInference.Builder#end()} to return to the current builder.
         * 
         * @return
         *     A new builder to build the value of the "keywordInference" property.
         *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.KeywordInference.Builder#end()} to return to the current builder.
         */
        public TerminologyInference.KeywordInference.Builder<? extends TerminologyInference.Builder<_B>> withKeywordInference() {
            return this.keywordInference = new TerminologyInference.KeywordInference.Builder<TerminologyInference.Builder<_B>>(this, null, false);
        }

        /**
         * Sets the new value of "callInferenceByName" (any previous value will be replaced)
         * 
         * @param callInferenceByName
         *     New value of the "callInferenceByName" property.
         */
        public TerminologyInference.Builder<_B> withCallInferenceByName(final String callInferenceByName) {
            this.callInferenceByName = callInferenceByName;
            return this;
        }

        @Override
        public TerminologyInference build() {
            if (_storedValue == null) {
                return this.init(new TerminologyInference());
            } else {
                return ((TerminologyInference) _storedValue);
            }
        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="sourceCodeSystem" type="{}Id"/&gt;
     *         &lt;element name="inferenceDefinition"&gt;
     *           &lt;complexType&gt;
     *             &lt;complexContent&gt;
     *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *                 &lt;choice&gt;
     *                   &lt;element name="localMappings"&gt;
     *                     &lt;complexType&gt;
     *                       &lt;complexContent&gt;
     *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *                           &lt;sequence&gt;
     *                             &lt;element name="mapping" maxOccurs="unbounded"&gt;
     *                               &lt;complexType&gt;
     *                                 &lt;complexContent&gt;
     *                                   &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *                                     &lt;attribute name="sourceValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
     *                                     &lt;attribute name="targetValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
     *                                     &lt;attribute name="sourceName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
     *                                     &lt;attribute name="targetName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
     *                                   &lt;/restriction&gt;
     *                                 &lt;/complexContent&gt;
     *                               &lt;/complexType&gt;
     *                             &lt;/element&gt;
     *                           &lt;/sequence&gt;
     *                         &lt;/restriction&gt;
     *                       &lt;/complexContent&gt;
     *                     &lt;/complexType&gt;
     *                   &lt;/element&gt;
     *                   &lt;element name="externalDefinition"&gt;
     *                     &lt;complexType&gt;
     *                       &lt;complexContent&gt;
     *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *                           &lt;sequence&gt;
     *                             &lt;element name="traverseAssociation" maxOccurs="unbounded" minOccurs="0"&gt;
     *                               &lt;complexType&gt;
     *                                 &lt;complexContent&gt;
     *                                   &lt;extension base="{}CD"&gt;
     *                                     &lt;attribute name="sequence" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" /&gt;
     *                                     &lt;attribute name="direction" use="required"&gt;
     *                                       &lt;simpleType&gt;
     *                                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
     *                                           &lt;enumeration value="DIRECT"/&gt;
     *                                           &lt;enumeration value="INVERSE"/&gt;
     *                                         &lt;/restriction&gt;
     *                                       &lt;/simpleType&gt;
     *                                     &lt;/attribute&gt;
     *                                     &lt;attribute name="maxConcepts" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
     *                                   &lt;/extension&gt;
     *                                 &lt;/complexContent&gt;
     *                               &lt;/complexType&gt;
     *                             &lt;/element&gt;
     *                             &lt;element name="codeProperty" type="{}Id"/&gt;
     *                             &lt;element name="displayNameProperty" type="{}Id"/&gt;
     *                           &lt;/sequence&gt;
     *                         &lt;/restriction&gt;
     *                       &lt;/complexContent&gt;
     *                     &lt;/complexType&gt;
     *                   &lt;/element&gt;
     *                 &lt;/choice&gt;
     *               &lt;/restriction&gt;
     *             &lt;/complexContent&gt;
     *           &lt;/complexType&gt;
     *         &lt;/element&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "sourceCodeSystem",
        "inferenceDefinition"
    })
    public static class CodeInference {

        @XmlElement(required = true)
        protected Id sourceCodeSystem;
        @XmlElement(required = true)
        protected TerminologyInference.CodeInference.InferenceDefinition inferenceDefinition;

        /**
         * Gets the value of the sourceCodeSystem property.
         * 
         * @return
         *     possible object is
         *     {@link Id }
         *     
         */
        public Id getSourceCodeSystem() {
            return sourceCodeSystem;
        }

        /**
         * Sets the value of the sourceCodeSystem property.
         * 
         * @param value
         *     allowed object is
         *     {@link Id }
         *     
         */
        public void setSourceCodeSystem(Id value) {
            this.sourceCodeSystem = value;
        }

        /**
         * Gets the value of the inferenceDefinition property.
         * 
         * @return
         *     possible object is
         *     {@link TerminologyInference.CodeInference.InferenceDefinition }
         *     
         */
        public TerminologyInference.CodeInference.InferenceDefinition getInferenceDefinition() {
            return inferenceDefinition;
        }

        /**
         * Sets the value of the inferenceDefinition property.
         * 
         * @param value
         *     allowed object is
         *     {@link TerminologyInference.CodeInference.InferenceDefinition }
         *     
         */
        public void setInferenceDefinition(TerminologyInference.CodeInference.InferenceDefinition value) {
            this.inferenceDefinition = value;
        }

        /**
         * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
         * 
         * @param _other
         *     A builder instance to which the state of this object will be copied.
         */
        public<_B >void copyTo(final TerminologyInference.CodeInference.Builder<_B> _other) {
            _other.sourceCodeSystem = ((this.sourceCodeSystem == null)?null:this.sourceCodeSystem.newCopyBuilder(_other));
            _other.inferenceDefinition = ((this.inferenceDefinition == null)?null:this.inferenceDefinition.newCopyBuilder(_other));
        }

        public<_B >TerminologyInference.CodeInference.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
            return new TerminologyInference.CodeInference.Builder<_B>(_parentBuilder, this, true);
        }

        public TerminologyInference.CodeInference.Builder<Void> newCopyBuilder() {
            return newCopyBuilder(null);
        }

        public static TerminologyInference.CodeInference.Builder<Void> builder() {
            return new TerminologyInference.CodeInference.Builder<Void>(null, null, false);
        }

        public static<_B >TerminologyInference.CodeInference.Builder<_B> copyOf(final TerminologyInference.CodeInference _other) {
            final TerminologyInference.CodeInference.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.Builder<_B>(null, null, false);
            _other.copyTo(_newBuilder);
            return _newBuilder;
        }

        /**
         * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
         * 
         * @param _other
         *     A builder instance to which the state of this object will be copied.
         */
        public<_B >void copyTo(final TerminologyInference.CodeInference.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            final PropertyTree sourceCodeSystemPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sourceCodeSystem"));
            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sourceCodeSystemPropertyTree!= null):((sourceCodeSystemPropertyTree == null)||(!sourceCodeSystemPropertyTree.isLeaf())))) {
                _other.sourceCodeSystem = ((this.sourceCodeSystem == null)?null:this.sourceCodeSystem.newCopyBuilder(_other, sourceCodeSystemPropertyTree, _propertyTreeUse));
            }
            final PropertyTree inferenceDefinitionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("inferenceDefinition"));
            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(inferenceDefinitionPropertyTree!= null):((inferenceDefinitionPropertyTree == null)||(!inferenceDefinitionPropertyTree.isLeaf())))) {
                _other.inferenceDefinition = ((this.inferenceDefinition == null)?null:this.inferenceDefinition.newCopyBuilder(_other, inferenceDefinitionPropertyTree, _propertyTreeUse));
            }
        }

        public<_B >TerminologyInference.CodeInference.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            return new TerminologyInference.CodeInference.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
        }

        public TerminologyInference.CodeInference.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
        }

        public static<_B >TerminologyInference.CodeInference.Builder<_B> copyOf(final TerminologyInference.CodeInference _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            final TerminologyInference.CodeInference.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.Builder<_B>(null, null, false);
            _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
            return _newBuilder;
        }

        public static TerminologyInference.CodeInference.Builder<Void> copyExcept(final TerminologyInference.CodeInference _other, final PropertyTree _propertyTree) {
            return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
        }

        public static TerminologyInference.CodeInference.Builder<Void> copyOnly(final TerminologyInference.CodeInference _other, final PropertyTree _propertyTree) {
            return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
        }

        public static class Builder<_B >implements Buildable
        {

            protected final _B _parentBuilder;
            protected final TerminologyInference.CodeInference _storedValue;
            private Id.Builder<TerminologyInference.CodeInference.Builder<_B>> sourceCodeSystem;
            private TerminologyInference.CodeInference.InferenceDefinition.Builder<TerminologyInference.CodeInference.Builder<_B>> inferenceDefinition;

            public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference _other, final boolean _copy) {
                this._parentBuilder = _parentBuilder;
                if (_other!= null) {
                    if (_copy) {
                        _storedValue = null;
                        this.sourceCodeSystem = ((_other.sourceCodeSystem == null)?null:_other.sourceCodeSystem.newCopyBuilder(this));
                        this.inferenceDefinition = ((_other.inferenceDefinition == null)?null:_other.inferenceDefinition.newCopyBuilder(this));
                    } else {
                        _storedValue = _other;
                    }
                } else {
                    _storedValue = null;
                }
            }

            public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                this._parentBuilder = _parentBuilder;
                if (_other!= null) {
                    if (_copy) {
                        _storedValue = null;
                        final PropertyTree sourceCodeSystemPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sourceCodeSystem"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sourceCodeSystemPropertyTree!= null):((sourceCodeSystemPropertyTree == null)||(!sourceCodeSystemPropertyTree.isLeaf())))) {
                            this.sourceCodeSystem = ((_other.sourceCodeSystem == null)?null:_other.sourceCodeSystem.newCopyBuilder(this, sourceCodeSystemPropertyTree, _propertyTreeUse));
                        }
                        final PropertyTree inferenceDefinitionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("inferenceDefinition"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(inferenceDefinitionPropertyTree!= null):((inferenceDefinitionPropertyTree == null)||(!inferenceDefinitionPropertyTree.isLeaf())))) {
                            this.inferenceDefinition = ((_other.inferenceDefinition == null)?null:_other.inferenceDefinition.newCopyBuilder(this, inferenceDefinitionPropertyTree, _propertyTreeUse));
                        }
                    } else {
                        _storedValue = _other;
                    }
                } else {
                    _storedValue = null;
                }
            }

            public _B end() {
                return this._parentBuilder;
            }

            protected<_P extends TerminologyInference.CodeInference >_P init(final _P _product) {
                _product.sourceCodeSystem = ((this.sourceCodeSystem == null)?null:this.sourceCodeSystem.build());
                _product.inferenceDefinition = ((this.inferenceDefinition == null)?null:this.inferenceDefinition.build());
                return _product;
            }

            /**
             * Sets the new value of "sourceCodeSystem" (any previous value will be replaced)
             * 
             * @param sourceCodeSystem
             *     New value of the "sourceCodeSystem" property.
             */
            public TerminologyInference.CodeInference.Builder<_B> withSourceCodeSystem(final Id sourceCodeSystem) {
                this.sourceCodeSystem = ((sourceCodeSystem == null)?null:new Id.Builder<TerminologyInference.CodeInference.Builder<_B>>(this, sourceCodeSystem, false));
                return this;
            }

            /**
             * Returns a new builder to build the value of the "sourceCodeSystem" property (replacing previous value).
             * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             * 
             * @return
             *     A new builder to build the value of the "sourceCodeSystem" property.
             *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             */
            public Id.Builder<? extends TerminologyInference.CodeInference.Builder<_B>> withSourceCodeSystem() {
                return this.sourceCodeSystem = new Id.Builder<TerminologyInference.CodeInference.Builder<_B>>(this, null, false);
            }

            /**
             * Sets the new value of "inferenceDefinition" (any previous value will be replaced)
             * 
             * @param inferenceDefinition
             *     New value of the "inferenceDefinition" property.
             */
            public TerminologyInference.CodeInference.Builder<_B> withInferenceDefinition(final TerminologyInference.CodeInference.InferenceDefinition inferenceDefinition) {
                this.inferenceDefinition = ((inferenceDefinition == null)?null:new TerminologyInference.CodeInference.InferenceDefinition.Builder<TerminologyInference.CodeInference.Builder<_B>>(this, inferenceDefinition, false));
                return this;
            }

            /**
             * Returns a new builder to build the value of the "inferenceDefinition" property (replacing previous value).
             * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.Builder#end()} to return to the current builder.
             * 
             * @return
             *     A new builder to build the value of the "inferenceDefinition" property.
             *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.Builder#end()} to return to the current builder.
             */
            public TerminologyInference.CodeInference.InferenceDefinition.Builder<? extends TerminologyInference.CodeInference.Builder<_B>> withInferenceDefinition() {
                return this.inferenceDefinition = new TerminologyInference.CodeInference.InferenceDefinition.Builder<TerminologyInference.CodeInference.Builder<_B>>(this, null, false);
            }

            @Override
            public TerminologyInference.CodeInference build() {
                if (_storedValue == null) {
                    return this.init(new TerminologyInference.CodeInference());
                } else {
                    return ((TerminologyInference.CodeInference) _storedValue);
                }
            }

        }


        /**
         * <p>Java class for anonymous complex type.
         * 
         * <p>The following schema fragment specifies the expected content contained within this class.
         * 
         * <pre>
         * &lt;complexType&gt;
         *   &lt;complexContent&gt;
         *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
         *       &lt;choice&gt;
         *         &lt;element name="localMappings"&gt;
         *           &lt;complexType&gt;
         *             &lt;complexContent&gt;
         *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
         *                 &lt;sequence&gt;
         *                   &lt;element name="mapping" maxOccurs="unbounded"&gt;
         *                     &lt;complexType&gt;
         *                       &lt;complexContent&gt;
         *                         &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
         *                           &lt;attribute name="sourceValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
         *                           &lt;attribute name="targetValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
         *                           &lt;attribute name="sourceName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
         *                           &lt;attribute name="targetName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
         *                         &lt;/restriction&gt;
         *                       &lt;/complexContent&gt;
         *                     &lt;/complexType&gt;
         *                   &lt;/element&gt;
         *                 &lt;/sequence&gt;
         *               &lt;/restriction&gt;
         *             &lt;/complexContent&gt;
         *           &lt;/complexType&gt;
         *         &lt;/element&gt;
         *         &lt;element name="externalDefinition"&gt;
         *           &lt;complexType&gt;
         *             &lt;complexContent&gt;
         *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
         *                 &lt;sequence&gt;
         *                   &lt;element name="traverseAssociation" maxOccurs="unbounded" minOccurs="0"&gt;
         *                     &lt;complexType&gt;
         *                       &lt;complexContent&gt;
         *                         &lt;extension base="{}CD"&gt;
         *                           &lt;attribute name="sequence" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" /&gt;
         *                           &lt;attribute name="direction" use="required"&gt;
         *                             &lt;simpleType&gt;
         *                               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
         *                                 &lt;enumeration value="DIRECT"/&gt;
         *                                 &lt;enumeration value="INVERSE"/&gt;
         *                               &lt;/restriction&gt;
         *                             &lt;/simpleType&gt;
         *                           &lt;/attribute&gt;
         *                           &lt;attribute name="maxConcepts" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
         *                         &lt;/extension&gt;
         *                       &lt;/complexContent&gt;
         *                     &lt;/complexType&gt;
         *                   &lt;/element&gt;
         *                   &lt;element name="codeProperty" type="{}Id"/&gt;
         *                   &lt;element name="displayNameProperty" type="{}Id"/&gt;
         *                 &lt;/sequence&gt;
         *               &lt;/restriction&gt;
         *             &lt;/complexContent&gt;
         *           &lt;/complexType&gt;
         *         &lt;/element&gt;
         *       &lt;/choice&gt;
         *     &lt;/restriction&gt;
         *   &lt;/complexContent&gt;
         * &lt;/complexType&gt;
         * </pre>
         * 
         * 
         */
        @XmlAccessorType(XmlAccessType.FIELD)
        @XmlType(name = "", propOrder = {
            "localMappings",
            "externalDefinition"
        })
        public static class InferenceDefinition {

            protected TerminologyInference.CodeInference.InferenceDefinition.LocalMappings localMappings;
            protected TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition externalDefinition;

            /**
             * Gets the value of the localMappings property.
             * 
             * @return
             *     possible object is
             *     {@link TerminologyInference.CodeInference.InferenceDefinition.LocalMappings }
             *     
             */
            public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings getLocalMappings() {
                return localMappings;
            }

            /**
             * Sets the value of the localMappings property.
             * 
             * @param value
             *     allowed object is
             *     {@link TerminologyInference.CodeInference.InferenceDefinition.LocalMappings }
             *     
             */
            public void setLocalMappings(TerminologyInference.CodeInference.InferenceDefinition.LocalMappings value) {
                this.localMappings = value;
            }

            /**
             * Gets the value of the externalDefinition property.
             * 
             * @return
             *     possible object is
             *     {@link TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition }
             *     
             */
            public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition getExternalDefinition() {
                return externalDefinition;
            }

            /**
             * Sets the value of the externalDefinition property.
             * 
             * @param value
             *     allowed object is
             *     {@link TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition }
             *     
             */
            public void setExternalDefinition(TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition value) {
                this.externalDefinition = value;
            }

            /**
             * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
             * 
             * @param _other
             *     A builder instance to which the state of this object will be copied.
             */
            public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> _other) {
                _other.localMappings = ((this.localMappings == null)?null:this.localMappings.newCopyBuilder(_other));
                _other.externalDefinition = ((this.externalDefinition == null)?null:this.externalDefinition.newCopyBuilder(_other));
            }

            public<_B >TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
                return new TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>(_parentBuilder, this, true);
            }

            public TerminologyInference.CodeInference.InferenceDefinition.Builder<Void> newCopyBuilder() {
                return newCopyBuilder(null);
            }

            public static TerminologyInference.CodeInference.InferenceDefinition.Builder<Void> builder() {
                return new TerminologyInference.CodeInference.InferenceDefinition.Builder<Void>(null, null, false);
            }

            public static<_B >TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition _other) {
                final TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>(null, null, false);
                _other.copyTo(_newBuilder);
                return _newBuilder;
            }

            /**
             * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
             * 
             * @param _other
             *     A builder instance to which the state of this object will be copied.
             */
            public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                final PropertyTree localMappingsPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("localMappings"));
                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(localMappingsPropertyTree!= null):((localMappingsPropertyTree == null)||(!localMappingsPropertyTree.isLeaf())))) {
                    _other.localMappings = ((this.localMappings == null)?null:this.localMappings.newCopyBuilder(_other, localMappingsPropertyTree, _propertyTreeUse));
                }
                final PropertyTree externalDefinitionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("externalDefinition"));
                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(externalDefinitionPropertyTree!= null):((externalDefinitionPropertyTree == null)||(!externalDefinitionPropertyTree.isLeaf())))) {
                    _other.externalDefinition = ((this.externalDefinition == null)?null:this.externalDefinition.newCopyBuilder(_other, externalDefinitionPropertyTree, _propertyTreeUse));
                }
            }

            public<_B >TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                return new TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
            }

            public TerminologyInference.CodeInference.InferenceDefinition.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
            }

            public static<_B >TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                final TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>(null, null, false);
                _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
                return _newBuilder;
            }

            public static TerminologyInference.CodeInference.InferenceDefinition.Builder<Void> copyExcept(final TerminologyInference.CodeInference.InferenceDefinition _other, final PropertyTree _propertyTree) {
                return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
            }

            public static TerminologyInference.CodeInference.InferenceDefinition.Builder<Void> copyOnly(final TerminologyInference.CodeInference.InferenceDefinition _other, final PropertyTree _propertyTree) {
                return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
            }

            public static class Builder<_B >implements Buildable
            {

                protected final _B _parentBuilder;
                protected final TerminologyInference.CodeInference.InferenceDefinition _storedValue;
                private TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>> localMappings;
                private TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>> externalDefinition;

                public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition _other, final boolean _copy) {
                    this._parentBuilder = _parentBuilder;
                    if (_other!= null) {
                        if (_copy) {
                            _storedValue = null;
                            this.localMappings = ((_other.localMappings == null)?null:_other.localMappings.newCopyBuilder(this));
                            this.externalDefinition = ((_other.externalDefinition == null)?null:_other.externalDefinition.newCopyBuilder(this));
                        } else {
                            _storedValue = _other;
                        }
                    } else {
                        _storedValue = null;
                    }
                }

                public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    this._parentBuilder = _parentBuilder;
                    if (_other!= null) {
                        if (_copy) {
                            _storedValue = null;
                            final PropertyTree localMappingsPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("localMappings"));
                            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(localMappingsPropertyTree!= null):((localMappingsPropertyTree == null)||(!localMappingsPropertyTree.isLeaf())))) {
                                this.localMappings = ((_other.localMappings == null)?null:_other.localMappings.newCopyBuilder(this, localMappingsPropertyTree, _propertyTreeUse));
                            }
                            final PropertyTree externalDefinitionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("externalDefinition"));
                            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(externalDefinitionPropertyTree!= null):((externalDefinitionPropertyTree == null)||(!externalDefinitionPropertyTree.isLeaf())))) {
                                this.externalDefinition = ((_other.externalDefinition == null)?null:_other.externalDefinition.newCopyBuilder(this, externalDefinitionPropertyTree, _propertyTreeUse));
                            }
                        } else {
                            _storedValue = _other;
                        }
                    } else {
                        _storedValue = null;
                    }
                }

                public _B end() {
                    return this._parentBuilder;
                }

                protected<_P extends TerminologyInference.CodeInference.InferenceDefinition >_P init(final _P _product) {
                    _product.localMappings = ((this.localMappings == null)?null:this.localMappings.build());
                    _product.externalDefinition = ((this.externalDefinition == null)?null:this.externalDefinition.build());
                    return _product;
                }

                /**
                 * Sets the new value of "localMappings" (any previous value will be replaced)
                 * 
                 * @param localMappings
                 *     New value of the "localMappings" property.
                 */
                public TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> withLocalMappings(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings localMappings) {
                    this.localMappings = ((localMappings == null)?null:new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>>(this, localMappings, false));
                    return this;
                }

                /**
                 * Returns a new builder to build the value of the "localMappings" property (replacing previous value).
                 * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder#end()} to return to the current builder.
                 * 
                 * @return
                 *     A new builder to build the value of the "localMappings" property.
                 *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder#end()} to return to the current builder.
                 */
                public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>> withLocalMappings() {
                    return this.localMappings = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>>(this, null, false);
                }

                /**
                 * Sets the new value of "externalDefinition" (any previous value will be replaced)
                 * 
                 * @param externalDefinition
                 *     New value of the "externalDefinition" property.
                 */
                public TerminologyInference.CodeInference.InferenceDefinition.Builder<_B> withExternalDefinition(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition externalDefinition) {
                    this.externalDefinition = ((externalDefinition == null)?null:new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>>(this, externalDefinition, false));
                    return this;
                }

                /**
                 * Returns a new builder to build the value of the "externalDefinition" property (replacing previous value).
                 * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder#end()} to return to the current builder.
                 * 
                 * @return
                 *     A new builder to build the value of the "externalDefinition" property.
                 *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder#end()} to return to the current builder.
                 */
                public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>> withExternalDefinition() {
                    return this.externalDefinition = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<TerminologyInference.CodeInference.InferenceDefinition.Builder<_B>>(this, null, false);
                }

                @Override
                public TerminologyInference.CodeInference.InferenceDefinition build() {
                    if (_storedValue == null) {
                        return this.init(new TerminologyInference.CodeInference.InferenceDefinition());
                    } else {
                        return ((TerminologyInference.CodeInference.InferenceDefinition) _storedValue);
                    }
                }

            }


            /**
             * <p>Java class for anonymous complex type.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.
             * 
             * <pre>
             * &lt;complexType&gt;
             *   &lt;complexContent&gt;
             *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
             *       &lt;sequence&gt;
             *         &lt;element name="traverseAssociation" maxOccurs="unbounded" minOccurs="0"&gt;
             *           &lt;complexType&gt;
             *             &lt;complexContent&gt;
             *               &lt;extension base="{}CD"&gt;
             *                 &lt;attribute name="sequence" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" /&gt;
             *                 &lt;attribute name="direction" use="required"&gt;
             *                   &lt;simpleType&gt;
             *                     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
             *                       &lt;enumeration value="DIRECT"/&gt;
             *                       &lt;enumeration value="INVERSE"/&gt;
             *                     &lt;/restriction&gt;
             *                   &lt;/simpleType&gt;
             *                 &lt;/attribute&gt;
             *                 &lt;attribute name="maxConcepts" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
             *               &lt;/extension&gt;
             *             &lt;/complexContent&gt;
             *           &lt;/complexType&gt;
             *         &lt;/element&gt;
             *         &lt;element name="codeProperty" type="{}Id"/&gt;
             *         &lt;element name="displayNameProperty" type="{}Id"/&gt;
             *       &lt;/sequence&gt;
             *     &lt;/restriction&gt;
             *   &lt;/complexContent&gt;
             * &lt;/complexType&gt;
             * </pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "traverseAssociation",
                "codeProperty",
                "displayNameProperty"
            })
            public static class ExternalDefinition {

                protected List<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation> traverseAssociation;
                @XmlElement(required = true)
                protected Id codeProperty;
                @XmlElement(required = true)
                protected Id displayNameProperty;

                /**
                 * Gets the value of the traverseAssociation property.
                 * 
                 * <p>
                 * This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object.
                 * This is why there is not a <CODE>set</CODE> method for the traverseAssociation property.
                 * 
                 * <p>
                 * For example, to add a new item, do as follows:
                 * <pre>
                 *    getTraverseAssociation().add(newItem);
                 * </pre>
                 * 
                 * 
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation }
                 * 
                 * 
                 */
                public List<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation> getTraverseAssociation() {
                    if (traverseAssociation == null) {
                        traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation>();
                    }
                    return this.traverseAssociation;
                }

                /**
                 * Gets the value of the codeProperty property.
                 * 
                 * @return
                 *     possible object is
                 *     {@link Id }
                 *     
                 */
                public Id getCodeProperty() {
                    return codeProperty;
                }

                /**
                 * Sets the value of the codeProperty property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link Id }
                 *     
                 */
                public void setCodeProperty(Id value) {
                    this.codeProperty = value;
                }

                /**
                 * Gets the value of the displayNameProperty property.
                 * 
                 * @return
                 *     possible object is
                 *     {@link Id }
                 *     
                 */
                public Id getDisplayNameProperty() {
                    return displayNameProperty;
                }

                /**
                 * Sets the value of the displayNameProperty property.
                 * 
                 * @param value
                 *     allowed object is
                 *     {@link Id }
                 *     
                 */
                public void setDisplayNameProperty(Id value) {
                    this.displayNameProperty = value;
                }

                /**
                 * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                 * 
                 * @param _other
                 *     A builder instance to which the state of this object will be copied.
                 */
                public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> _other) {
                    if (this.traverseAssociation == null) {
                        _other.traverseAssociation = null;
                    } else {
                        _other.traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>>();
                        for (TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _item: this.traverseAssociation) {
                            _other.traverseAssociation.add(((_item == null)?null:_item.newCopyBuilder(_other)));
                        }
                    }
                    _other.codeProperty = ((this.codeProperty == null)?null:this.codeProperty.newCopyBuilder(_other));
                    _other.displayNameProperty = ((this.displayNameProperty == null)?null:this.displayNameProperty.newCopyBuilder(_other));
                }

                public<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
                    return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>(_parentBuilder, this, true);
                }

                public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<Void> newCopyBuilder() {
                    return newCopyBuilder(null);
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<Void> builder() {
                    return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<Void>(null, null, false);
                }

                public static<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _other) {
                    final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>(null, null, false);
                    _other.copyTo(_newBuilder);
                    return _newBuilder;
                }

                /**
                 * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                 * 
                 * @param _other
                 *     A builder instance to which the state of this object will be copied.
                 */
                public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    final PropertyTree traverseAssociationPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("traverseAssociation"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(traverseAssociationPropertyTree!= null):((traverseAssociationPropertyTree == null)||(!traverseAssociationPropertyTree.isLeaf())))) {
                        if (this.traverseAssociation == null) {
                            _other.traverseAssociation = null;
                        } else {
                            _other.traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>>();
                            for (TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _item: this.traverseAssociation) {
                                _other.traverseAssociation.add(((_item == null)?null:_item.newCopyBuilder(_other, traverseAssociationPropertyTree, _propertyTreeUse)));
                            }
                        }
                    }
                    final PropertyTree codePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("codeProperty"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(codePropertyPropertyTree!= null):((codePropertyPropertyTree == null)||(!codePropertyPropertyTree.isLeaf())))) {
                        _other.codeProperty = ((this.codeProperty == null)?null:this.codeProperty.newCopyBuilder(_other, codePropertyPropertyTree, _propertyTreeUse));
                    }
                    final PropertyTree displayNamePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("displayNameProperty"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(displayNamePropertyPropertyTree!= null):((displayNamePropertyPropertyTree == null)||(!displayNamePropertyPropertyTree.isLeaf())))) {
                        _other.displayNameProperty = ((this.displayNameProperty == null)?null:this.displayNameProperty.newCopyBuilder(_other, displayNamePropertyPropertyTree, _propertyTreeUse));
                    }
                }

                public<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
                }

                public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
                }

                public static<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>(null, null, false);
                    _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
                    return _newBuilder;
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<Void> copyExcept(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _other, final PropertyTree _propertyTree) {
                    return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<Void> copyOnly(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _other, final PropertyTree _propertyTree) {
                    return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
                }

                public static class Builder<_B >implements Buildable
                {

                    protected final _B _parentBuilder;
                    protected final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _storedValue;
                    private List<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>> traverseAssociation;
                    private Id.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> codeProperty;
                    private Id.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> displayNameProperty;

                    public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _other, final boolean _copy) {
                        this._parentBuilder = _parentBuilder;
                        if (_other!= null) {
                            if (_copy) {
                                _storedValue = null;
                                if (_other.traverseAssociation == null) {
                                    this.traverseAssociation = null;
                                } else {
                                    this.traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>>();
                                    for (TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _item: _other.traverseAssociation) {
                                        this.traverseAssociation.add(((_item == null)?null:_item.newCopyBuilder(this)));
                                    }
                                }
                                this.codeProperty = ((_other.codeProperty == null)?null:_other.codeProperty.newCopyBuilder(this));
                                this.displayNameProperty = ((_other.displayNameProperty == null)?null:_other.displayNameProperty.newCopyBuilder(this));
                            } else {
                                _storedValue = _other;
                            }
                        } else {
                            _storedValue = null;
                        }
                    }

                    public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        this._parentBuilder = _parentBuilder;
                        if (_other!= null) {
                            if (_copy) {
                                _storedValue = null;
                                final PropertyTree traverseAssociationPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("traverseAssociation"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(traverseAssociationPropertyTree!= null):((traverseAssociationPropertyTree == null)||(!traverseAssociationPropertyTree.isLeaf())))) {
                                    if (_other.traverseAssociation == null) {
                                        this.traverseAssociation = null;
                                    } else {
                                        this.traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>>();
                                        for (TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _item: _other.traverseAssociation) {
                                            this.traverseAssociation.add(((_item == null)?null:_item.newCopyBuilder(this, traverseAssociationPropertyTree, _propertyTreeUse)));
                                        }
                                    }
                                }
                                final PropertyTree codePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("codeProperty"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(codePropertyPropertyTree!= null):((codePropertyPropertyTree == null)||(!codePropertyPropertyTree.isLeaf())))) {
                                    this.codeProperty = ((_other.codeProperty == null)?null:_other.codeProperty.newCopyBuilder(this, codePropertyPropertyTree, _propertyTreeUse));
                                }
                                final PropertyTree displayNamePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("displayNameProperty"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(displayNamePropertyPropertyTree!= null):((displayNamePropertyPropertyTree == null)||(!displayNamePropertyPropertyTree.isLeaf())))) {
                                    this.displayNameProperty = ((_other.displayNameProperty == null)?null:_other.displayNameProperty.newCopyBuilder(this, displayNamePropertyPropertyTree, _propertyTreeUse));
                                }
                            } else {
                                _storedValue = _other;
                            }
                        } else {
                            _storedValue = null;
                        }
                    }

                    public _B end() {
                        return this._parentBuilder;
                    }

                    protected<_P extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition >_P init(final _P _product) {
                        if (this.traverseAssociation!= null) {
                            final List<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation> traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation>(this.traverseAssociation.size());
                            for (TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> _item: this.traverseAssociation) {
                                traverseAssociation.add(_item.build());
                            }
                            _product.traverseAssociation = traverseAssociation;
                        }
                        _product.codeProperty = ((this.codeProperty == null)?null:this.codeProperty.build());
                        _product.displayNameProperty = ((this.displayNameProperty == null)?null:this.displayNameProperty.build());
                        return _product;
                    }

                    /**
                     * Adds the given items to the value of "traverseAssociation"
                     * 
                     * @param traverseAssociation
                     *     Items to add to the value of the "traverseAssociation" property
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> addTraverseAssociation(final Iterable<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation> traverseAssociation) {
                        if (traverseAssociation!= null) {
                            if (this.traverseAssociation == null) {
                                this.traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>>();
                            }
                            for (TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _item: traverseAssociation) {
                                this.traverseAssociation.add(new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>(this, _item, false));
                            }
                        }
                        return this;
                    }

                    /**
                     * Sets the new value of "traverseAssociation" (any previous value will be replaced)
                     * 
                     * @param traverseAssociation
                     *     New value of the "traverseAssociation" property.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> withTraverseAssociation(final Iterable<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation> traverseAssociation) {
                        if (this.traverseAssociation!= null) {
                            this.traverseAssociation.clear();
                        }
                        return addTraverseAssociation(traverseAssociation);
                    }

                    /**
                     * Adds the given items to the value of "traverseAssociation"
                     * 
                     * @param traverseAssociation
                     *     Items to add to the value of the "traverseAssociation" property
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> addTraverseAssociation(TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation... traverseAssociation) {
                        addTraverseAssociation(Arrays.asList(traverseAssociation));
                        return this;
                    }

                    /**
                     * Sets the new value of "traverseAssociation" (any previous value will be replaced)
                     * 
                     * @param traverseAssociation
                     *     New value of the "traverseAssociation" property.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> withTraverseAssociation(TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation... traverseAssociation) {
                        withTraverseAssociation(Arrays.asList(traverseAssociation));
                        return this;
                    }

                    /**
                     * Returns a new builder to build an additional value of the "TraverseAssociation" property.
                     * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder#end()} to return to the current builder.
                     * 
                     * @return
                     *     a new builder to build an additional value of the "TraverseAssociation" property.
                     *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder#end()} to return to the current builder.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> addTraverseAssociation() {
                        if (this.traverseAssociation == null) {
                            this.traverseAssociation = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>>();
                        }
                        final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> traverseAssociation_Builder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>(this, null, false);
                        this.traverseAssociation.add(traverseAssociation_Builder);
                        return traverseAssociation_Builder;
                    }

                    /**
                     * Sets the new value of "codeProperty" (any previous value will be replaced)
                     * 
                     * @param codeProperty
                     *     New value of the "codeProperty" property.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> withCodeProperty(final Id codeProperty) {
                        this.codeProperty = ((codeProperty == null)?null:new Id.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>(this, codeProperty, false));
                        return this;
                    }

                    /**
                     * Returns a new builder to build the value of the "codeProperty" property (replacing previous value).
                     * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
                     * 
                     * @return
                     *     A new builder to build the value of the "codeProperty" property.
                     *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
                     */
                    public Id.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> withCodeProperty() {
                        return this.codeProperty = new Id.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>(this, null, false);
                    }

                    /**
                     * Sets the new value of "displayNameProperty" (any previous value will be replaced)
                     * 
                     * @param displayNameProperty
                     *     New value of the "displayNameProperty" property.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B> withDisplayNameProperty(final Id displayNameProperty) {
                        this.displayNameProperty = ((displayNameProperty == null)?null:new Id.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>(this, displayNameProperty, false));
                        return this;
                    }

                    /**
                     * Returns a new builder to build the value of the "displayNameProperty" property (replacing previous value).
                     * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
                     * 
                     * @return
                     *     A new builder to build the value of the "displayNameProperty" property.
                     *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
                     */
                    public Id.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>> withDisplayNameProperty() {
                        return this.displayNameProperty = new Id.Builder<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Builder<_B>>(this, null, false);
                    }

                    @Override
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition build() {
                        if (_storedValue == null) {
                            return this.init(new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition());
                        } else {
                            return ((TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition) _storedValue);
                        }
                    }

                }

                public static class Select
                    extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Select, Void>
                {


                    Select() {
                        super(null, null, null);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Select _root() {
                        return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Select();
                    }

                }

                public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
                    extends com.kscs.util.jaxb.Selector<TRoot, TParent>
                {

                    private TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>> traverseAssociation = null;
                    private Id.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>> codeProperty = null;
                    private Id.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>> displayNameProperty = null;

                    public Selector(final TRoot root, final TParent parent, final String propertyName) {
                        super(root, parent, propertyName);
                    }

                    @Override
                    public Map<String, PropertyTree> buildChildren() {
                        final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                        products.putAll(super.buildChildren());
                        if (this.traverseAssociation!= null) {
                            products.put("traverseAssociation", this.traverseAssociation.init());
                        }
                        if (this.codeProperty!= null) {
                            products.put("codeProperty", this.codeProperty.init());
                        }
                        if (this.displayNameProperty!= null) {
                            products.put("displayNameProperty", this.displayNameProperty.init());
                        }
                        return products;
                    }

                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>> traverseAssociation() {
                        return ((this.traverseAssociation == null)?this.traverseAssociation = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>>(this._root, this, "traverseAssociation"):this.traverseAssociation);
                    }

                    public Id.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>> codeProperty() {
                        return ((this.codeProperty == null)?this.codeProperty = new Id.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>>(this._root, this, "codeProperty"):this.codeProperty);
                    }

                    public Id.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>> displayNameProperty() {
                        return ((this.displayNameProperty == null)?this.displayNameProperty = new Id.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TParent>>(this._root, this, "displayNameProperty"):this.displayNameProperty);
                    }

                }


                /**
                 * <p>Java class for anonymous complex type.
                 * 
                 * <p>The following schema fragment specifies the expected content contained within this class.
                 * 
                 * <pre>
                 * &lt;complexType&gt;
                 *   &lt;complexContent&gt;
                 *     &lt;extension base="{}CD"&gt;
                 *       &lt;attribute name="sequence" use="required" type="{http://www.w3.org/2001/XMLSchema}anySimpleType" /&gt;
                 *       &lt;attribute name="direction" use="required"&gt;
                 *         &lt;simpleType&gt;
                 *           &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string"&gt;
                 *             &lt;enumeration value="DIRECT"/&gt;
                 *             &lt;enumeration value="INVERSE"/&gt;
                 *           &lt;/restriction&gt;
                 *         &lt;/simpleType&gt;
                 *       &lt;/attribute&gt;
                 *       &lt;attribute name="maxConcepts" type="{http://www.w3.org/2001/XMLSchema}int" /&gt;
                 *     &lt;/extension&gt;
                 *   &lt;/complexContent&gt;
                 * &lt;/complexType&gt;
                 * </pre>
                 * 
                 * 
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "")
                public static class TraverseAssociation
                    extends CD
                {

                    @XmlAttribute(name = "sequence", required = true)
                    @XmlSchemaType(name = "anySimpleType")
                    protected String sequence;
                    @XmlAttribute(name = "direction", required = true)
                    protected String direction;
                    @XmlAttribute(name = "maxConcepts")
                    protected Integer maxConcepts;

                    /**
                     * Gets the value of the sequence property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getSequence() {
                        return sequence;
                    }

                    /**
                     * Sets the value of the sequence property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     */
                    public void setSequence(String value) {
                        this.sequence = value;
                    }

                    /**
                     * Gets the value of the direction property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getDirection() {
                        return direction;
                    }

                    /**
                     * Sets the value of the direction property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     */
                    public void setDirection(String value) {
                        this.direction = value;
                    }

                    /**
                     * Gets the value of the maxConcepts property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link Integer }
                     *     
                     */
                    public Integer getMaxConcepts() {
                        return maxConcepts;
                    }

                    /**
                     * Sets the value of the maxConcepts property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link Integer }
                     *     
                     */
                    public void setMaxConcepts(Integer value) {
                        this.maxConcepts = value;
                    }

                    /**
                     * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                     * 
                     * @param _other
                     *     A builder instance to which the state of this object will be copied.
                     */
                    public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> _other) {
                        super.copyTo(_other);
                        _other.sequence = this.sequence;
                        _other.direction = this.direction;
                        _other.maxConcepts = this.maxConcepts;
                    }

                    @Override
                    public<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
                        return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>(_parentBuilder, this, true);
                    }

                    @Override
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> newCopyBuilder() {
                        return newCopyBuilder(null);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> builder() {
                        return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void>(null, null, false);
                    }

                    public static<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> copyOf(final CD _other) {
                        final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>(null, null, false);
                        _other.copyTo(_newBuilder);
                        return _newBuilder;
                    }

                    public static<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _other) {
                        final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>(null, null, false);
                        _other.copyTo(_newBuilder);
                        return _newBuilder;
                    }

                    /**
                     * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                     * 
                     * @param _other
                     *     A builder instance to which the state of this object will be copied.
                     */
                    public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        super.copyTo(_other, _propertyTree, _propertyTreeUse);
                        final PropertyTree sequencePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sequence"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sequencePropertyTree!= null):((sequencePropertyTree == null)||(!sequencePropertyTree.isLeaf())))) {
                            _other.sequence = this.sequence;
                        }
                        final PropertyTree directionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("direction"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(directionPropertyTree!= null):((directionPropertyTree == null)||(!directionPropertyTree.isLeaf())))) {
                            _other.direction = this.direction;
                        }
                        final PropertyTree maxConceptsPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("maxConcepts"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(maxConceptsPropertyTree!= null):((maxConceptsPropertyTree == null)||(!maxConceptsPropertyTree.isLeaf())))) {
                            _other.maxConcepts = this.maxConcepts;
                        }
                    }

                    @Override
                    public<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
                    }

                    @Override
                    public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
                    }

                    public static<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> copyOf(final CD _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>(null, null, false);
                        _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
                        return _newBuilder;
                    }

                    public static<_B >TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>(null, null, false);
                        _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
                        return _newBuilder;
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> copyExcept(final CD _other, final PropertyTree _propertyTree) {
                        return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> copyExcept(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _other, final PropertyTree _propertyTree) {
                        return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> copyOnly(final CD _other, final PropertyTree _propertyTree) {
                        return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<Void> copyOnly(final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _other, final PropertyTree _propertyTree) {
                        return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
                    }

                    public static class Builder<_B >
                        extends CD.Builder<_B>
                        implements Buildable
                    {

                        private String sequence;
                        private String direction;
                        private Integer maxConcepts;

                        public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _other, final boolean _copy) {
                            super(_parentBuilder, _other, _copy);
                            if (_other!= null) {
                                this.sequence = _other.sequence;
                                this.direction = _other.direction;
                                this.maxConcepts = _other.maxConcepts;
                            }
                        }

                        public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                            super(_parentBuilder, _other, _copy, _propertyTree, _propertyTreeUse);
                            if (_other!= null) {
                                final PropertyTree sequencePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sequence"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sequencePropertyTree!= null):((sequencePropertyTree == null)||(!sequencePropertyTree.isLeaf())))) {
                                    this.sequence = _other.sequence;
                                }
                                final PropertyTree directionPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("direction"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(directionPropertyTree!= null):((directionPropertyTree == null)||(!directionPropertyTree.isLeaf())))) {
                                    this.direction = _other.direction;
                                }
                                final PropertyTree maxConceptsPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("maxConcepts"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(maxConceptsPropertyTree!= null):((maxConceptsPropertyTree == null)||(!maxConceptsPropertyTree.isLeaf())))) {
                                    this.maxConcepts = _other.maxConcepts;
                                }
                            }
                        }

                        protected<_P extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation >_P init(final _P _product) {
                            _product.sequence = this.sequence;
                            _product.direction = this.direction;
                            _product.maxConcepts = this.maxConcepts;
                            return super.init(_product);
                        }

                        /**
                         * Sets the new value of "sequence" (any previous value will be replaced)
                         * 
                         * @param sequence
                         *     New value of the "sequence" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> withSequence(final String sequence) {
                            this.sequence = sequence;
                            return this;
                        }

                        /**
                         * Sets the new value of "direction" (any previous value will be replaced)
                         * 
                         * @param direction
                         *     New value of the "direction" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> withDirection(final String direction) {
                            this.direction = direction;
                            return this;
                        }

                        /**
                         * Sets the new value of "maxConcepts" (any previous value will be replaced)
                         * 
                         * @param maxConcepts
                         *     New value of the "maxConcepts" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> withMaxConcepts(final Integer maxConcepts) {
                            this.maxConcepts = maxConcepts;
                            return this;
                        }

                        /**
                         * Sets the new value of "code" (any previous value will be replaced)
                         * 
                         * @param code
                         *     New value of the "code" property.
                         */
                        @Override
                        public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B> withCode(final Code code) {
                            super.withCode(code);
                            return this;
                        }

                        /**
                         * Returns a new builder to build the value of the "code" property (replacing previous value).
                         * Use {@link org.openinfobutton.schemas.kb.Code.Builder#end()} to return to the current builder.
                         * 
                         * @return
                         *     A new builder to build the value of the "code" property.
                         *     Use {@link org.openinfobutton.schemas.kb.Code.Builder#end()} to return to the current builder.
                         */
                        public Code.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>> withCode() {
                            return ((Code.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Builder<_B>> ) super.withCode());
                        }

                        @Override
                        public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation build() {
                            if (_storedValue == null) {
                                return this.init(new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation());
                            } else {
                                return ((TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation) _storedValue);
                            }
                        }

                    }

                    public static class Select
                        extends TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Select, Void>
                    {


                        Select() {
                            super(null, null, null);
                        }

                        public static TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Select _root() {
                            return new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Select();
                        }

                    }

                    public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
                        extends CD.Selector<TRoot, TParent>
                    {

                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>> sequence = null;
                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>> direction = null;
                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>> maxConcepts = null;

                        public Selector(final TRoot root, final TParent parent, final String propertyName) {
                            super(root, parent, propertyName);
                        }

                        @Override
                        public Map<String, PropertyTree> buildChildren() {
                            final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                            products.putAll(super.buildChildren());
                            if (this.sequence!= null) {
                                products.put("sequence", this.sequence.init());
                            }
                            if (this.direction!= null) {
                                products.put("direction", this.direction.init());
                            }
                            if (this.maxConcepts!= null) {
                                products.put("maxConcepts", this.maxConcepts.init());
                            }
                            return products;
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>> sequence() {
                            return ((this.sequence == null)?this.sequence = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>>(this._root, this, "sequence"):this.sequence);
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>> direction() {
                            return ((this.direction == null)?this.direction = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>>(this._root, this, "direction"):this.direction);
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>> maxConcepts() {
                            return ((this.maxConcepts == null)?this.maxConcepts = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.TraverseAssociation.Selector<TRoot, TParent>>(this._root, this, "maxConcepts"):this.maxConcepts);
                        }

                    }

                }

            }


            /**
             * <p>Java class for anonymous complex type.
             * 
             * <p>The following schema fragment specifies the expected content contained within this class.
             * 
             * <pre>
             * &lt;complexType&gt;
             *   &lt;complexContent&gt;
             *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
             *       &lt;sequence&gt;
             *         &lt;element name="mapping" maxOccurs="unbounded"&gt;
             *           &lt;complexType&gt;
             *             &lt;complexContent&gt;
             *               &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
             *                 &lt;attribute name="sourceValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
             *                 &lt;attribute name="targetValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
             *                 &lt;attribute name="sourceName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
             *                 &lt;attribute name="targetName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
             *               &lt;/restriction&gt;
             *             &lt;/complexContent&gt;
             *           &lt;/complexType&gt;
             *         &lt;/element&gt;
             *       &lt;/sequence&gt;
             *     &lt;/restriction&gt;
             *   &lt;/complexContent&gt;
             * &lt;/complexType&gt;
             * </pre>
             * 
             * 
             */
            @XmlAccessorType(XmlAccessType.FIELD)
            @XmlType(name = "", propOrder = {
                "mapping"
            })
            public static class LocalMappings {

                @XmlElement(required = true)
                protected List<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping> mapping;

                /**
                 * Gets the value of the mapping property.
                 * 
                 * <p>
                 * This accessor method returns a reference to the live list,
                 * not a snapshot. Therefore any modification you make to the
                 * returned list will be present inside the JAXB object.
                 * This is why there is not a <CODE>set</CODE> method for the mapping property.
                 * 
                 * <p>
                 * For example, to add a new item, do as follows:
                 * <pre>
                 *    getMapping().add(newItem);
                 * </pre>
                 * 
                 * 
                 * <p>
                 * Objects of the following type(s) are allowed in the list
                 * {@link TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping }
                 * 
                 * 
                 */
                public List<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping> getMapping() {
                    if (mapping == null) {
                        mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping>();
                    }
                    return this.mapping;
                }

                /**
                 * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                 * 
                 * @param _other
                 *     A builder instance to which the state of this object will be copied.
                 */
                public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> _other) {
                    if (this.mapping == null) {
                        _other.mapping = null;
                    } else {
                        _other.mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>>();
                        for (TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _item: this.mapping) {
                            _other.mapping.add(((_item == null)?null:_item.newCopyBuilder(_other)));
                        }
                    }
                }

                public<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
                    return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>(_parentBuilder, this, true);
                }

                public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<Void> newCopyBuilder() {
                    return newCopyBuilder(null);
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<Void> builder() {
                    return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<Void>(null, null, false);
                }

                public static<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _other) {
                    final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>(null, null, false);
                    _other.copyTo(_newBuilder);
                    return _newBuilder;
                }

                /**
                 * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                 * 
                 * @param _other
                 *     A builder instance to which the state of this object will be copied.
                 */
                public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    final PropertyTree mappingPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("mapping"));
                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(mappingPropertyTree!= null):((mappingPropertyTree == null)||(!mappingPropertyTree.isLeaf())))) {
                        if (this.mapping == null) {
                            _other.mapping = null;
                        } else {
                            _other.mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>>();
                            for (TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _item: this.mapping) {
                                _other.mapping.add(((_item == null)?null:_item.newCopyBuilder(_other, mappingPropertyTree, _propertyTreeUse)));
                            }
                        }
                    }
                }

                public<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
                }

                public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
                }

                public static<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                    final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>(null, null, false);
                    _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
                    return _newBuilder;
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<Void> copyExcept(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _other, final PropertyTree _propertyTree) {
                    return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<Void> copyOnly(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _other, final PropertyTree _propertyTree) {
                    return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
                }

                public static class Builder<_B >implements Buildable
                {

                    protected final _B _parentBuilder;
                    protected final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _storedValue;
                    private List<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>> mapping;

                    public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _other, final boolean _copy) {
                        this._parentBuilder = _parentBuilder;
                        if (_other!= null) {
                            if (_copy) {
                                _storedValue = null;
                                if (_other.mapping == null) {
                                    this.mapping = null;
                                } else {
                                    this.mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>>();
                                    for (TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _item: _other.mapping) {
                                        this.mapping.add(((_item == null)?null:_item.newCopyBuilder(this)));
                                    }
                                }
                            } else {
                                _storedValue = _other;
                            }
                        } else {
                            _storedValue = null;
                        }
                    }

                    public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        this._parentBuilder = _parentBuilder;
                        if (_other!= null) {
                            if (_copy) {
                                _storedValue = null;
                                final PropertyTree mappingPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("mapping"));
                                if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(mappingPropertyTree!= null):((mappingPropertyTree == null)||(!mappingPropertyTree.isLeaf())))) {
                                    if (_other.mapping == null) {
                                        this.mapping = null;
                                    } else {
                                        this.mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>>();
                                        for (TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _item: _other.mapping) {
                                            this.mapping.add(((_item == null)?null:_item.newCopyBuilder(this, mappingPropertyTree, _propertyTreeUse)));
                                        }
                                    }
                                }
                            } else {
                                _storedValue = _other;
                            }
                        } else {
                            _storedValue = null;
                        }
                    }

                    public _B end() {
                        return this._parentBuilder;
                    }

                    protected<_P extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings >_P init(final _P _product) {
                        if (this.mapping!= null) {
                            final List<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping> mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping>(this.mapping.size());
                            for (TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>> _item: this.mapping) {
                                mapping.add(_item.build());
                            }
                            _product.mapping = mapping;
                        }
                        return _product;
                    }

                    /**
                     * Adds the given items to the value of "mapping"
                     * 
                     * @param mapping
                     *     Items to add to the value of the "mapping" property
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> addMapping(final Iterable<? extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping> mapping) {
                        if (mapping!= null) {
                            if (this.mapping == null) {
                                this.mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>>();
                            }
                            for (TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _item: mapping) {
                                this.mapping.add(new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>(this, _item, false));
                            }
                        }
                        return this;
                    }

                    /**
                     * Sets the new value of "mapping" (any previous value will be replaced)
                     * 
                     * @param mapping
                     *     New value of the "mapping" property.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> withMapping(final Iterable<? extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping> mapping) {
                        if (this.mapping!= null) {
                            this.mapping.clear();
                        }
                        return addMapping(mapping);
                    }

                    /**
                     * Adds the given items to the value of "mapping"
                     * 
                     * @param mapping
                     *     Items to add to the value of the "mapping" property
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> addMapping(TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping... mapping) {
                        addMapping(Arrays.asList(mapping));
                        return this;
                    }

                    /**
                     * Sets the new value of "mapping" (any previous value will be replaced)
                     * 
                     * @param mapping
                     *     New value of the "mapping" property.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B> withMapping(TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping... mapping) {
                        withMapping(Arrays.asList(mapping));
                        return this;
                    }

                    /**
                     * Returns a new builder to build an additional value of the "Mapping" property.
                     * Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder#end()} to return to the current builder.
                     * 
                     * @return
                     *     a new builder to build an additional value of the "Mapping" property.
                     *     Use {@link org.openinfobutton.schemas.kb.TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder#end()} to return to the current builder.
                     */
                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<? extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>> addMapping() {
                        if (this.mapping == null) {
                            this.mapping = new ArrayList<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>>();
                        }
                        final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>> mapping_Builder = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Builder<_B>>(this, null, false);
                        this.mapping.add(mapping_Builder);
                        return mapping_Builder;
                    }

                    @Override
                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings build() {
                        if (_storedValue == null) {
                            return this.init(new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings());
                        } else {
                            return ((TerminologyInference.CodeInference.InferenceDefinition.LocalMappings) _storedValue);
                        }
                    }

                }


                /**
                 * <p>Java class for anonymous complex type.
                 * 
                 * <p>The following schema fragment specifies the expected content contained within this class.
                 * 
                 * <pre>
                 * &lt;complexType&gt;
                 *   &lt;complexContent&gt;
                 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
                 *       &lt;attribute name="sourceValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
                 *       &lt;attribute name="targetValue" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
                 *       &lt;attribute name="sourceName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
                 *       &lt;attribute name="targetName" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
                 *     &lt;/restriction&gt;
                 *   &lt;/complexContent&gt;
                 * &lt;/complexType&gt;
                 * </pre>
                 * 
                 * 
                 */
                @XmlAccessorType(XmlAccessType.FIELD)
                @XmlType(name = "")
                public static class Mapping {

                    @XmlAttribute(name = "sourceValue", required = true)
                    protected String sourceValue;
                    @XmlAttribute(name = "targetValue", required = true)
                    protected String targetValue;
                    @XmlAttribute(name = "sourceName", required = true)
                    protected String sourceName;
                    @XmlAttribute(name = "targetName", required = true)
                    protected String targetName;

                    /**
                     * Gets the value of the sourceValue property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getSourceValue() {
                        return sourceValue;
                    }

                    /**
                     * Sets the value of the sourceValue property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     */
                    public void setSourceValue(String value) {
                        this.sourceValue = value;
                    }

                    /**
                     * Gets the value of the targetValue property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getTargetValue() {
                        return targetValue;
                    }

                    /**
                     * Sets the value of the targetValue property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     */
                    public void setTargetValue(String value) {
                        this.targetValue = value;
                    }

                    /**
                     * Gets the value of the sourceName property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getSourceName() {
                        return sourceName;
                    }

                    /**
                     * Sets the value of the sourceName property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     */
                    public void setSourceName(String value) {
                        this.sourceName = value;
                    }

                    /**
                     * Gets the value of the targetName property.
                     * 
                     * @return
                     *     possible object is
                     *     {@link String }
                     *     
                     */
                    public String getTargetName() {
                        return targetName;
                    }

                    /**
                     * Sets the value of the targetName property.
                     * 
                     * @param value
                     *     allowed object is
                     *     {@link String }
                     *     
                     */
                    public void setTargetName(String value) {
                        this.targetName = value;
                    }

                    /**
                     * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                     * 
                     * @param _other
                     *     A builder instance to which the state of this object will be copied.
                     */
                    public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> _other) {
                        _other.sourceValue = this.sourceValue;
                        _other.targetValue = this.targetValue;
                        _other.sourceName = this.sourceName;
                        _other.targetName = this.targetName;
                    }

                    public<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
                        return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B>(_parentBuilder, this, true);
                    }

                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<Void> newCopyBuilder() {
                        return newCopyBuilder(null);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<Void> builder() {
                        return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<Void>(null, null, false);
                    }

                    public static<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _other) {
                        final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B>(null, null, false);
                        _other.copyTo(_newBuilder);
                        return _newBuilder;
                    }

                    /**
                     * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
                     * 
                     * @param _other
                     *     A builder instance to which the state of this object will be copied.
                     */
                    public<_B >void copyTo(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        final PropertyTree sourceValuePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sourceValue"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sourceValuePropertyTree!= null):((sourceValuePropertyTree == null)||(!sourceValuePropertyTree.isLeaf())))) {
                            _other.sourceValue = this.sourceValue;
                        }
                        final PropertyTree targetValuePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("targetValue"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(targetValuePropertyTree!= null):((targetValuePropertyTree == null)||(!targetValuePropertyTree.isLeaf())))) {
                            _other.targetValue = this.targetValue;
                        }
                        final PropertyTree sourceNamePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sourceName"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sourceNamePropertyTree!= null):((sourceNamePropertyTree == null)||(!sourceNamePropertyTree.isLeaf())))) {
                            _other.sourceName = this.sourceName;
                        }
                        final PropertyTree targetNamePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("targetName"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(targetNamePropertyTree!= null):((targetNamePropertyTree == null)||(!targetNamePropertyTree.isLeaf())))) {
                            _other.targetName = this.targetName;
                        }
                    }

                    public<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
                    }

                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
                    }

                    public static<_B >TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> copyOf(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                        final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> _newBuilder = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B>(null, null, false);
                        _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
                        return _newBuilder;
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<Void> copyExcept(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _other, final PropertyTree _propertyTree) {
                        return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<Void> copyOnly(final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _other, final PropertyTree _propertyTree) {
                        return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
                    }

                    public static class Builder<_B >implements Buildable
                    {

                        protected final _B _parentBuilder;
                        protected final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _storedValue;
                        private String sourceValue;
                        private String targetValue;
                        private String sourceName;
                        private String targetName;

                        public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _other, final boolean _copy) {
                            this._parentBuilder = _parentBuilder;
                            if (_other!= null) {
                                if (_copy) {
                                    _storedValue = null;
                                    this.sourceValue = _other.sourceValue;
                                    this.targetValue = _other.targetValue;
                                    this.sourceName = _other.sourceName;
                                    this.targetName = _other.targetName;
                                } else {
                                    _storedValue = _other;
                                }
                            } else {
                                _storedValue = null;
                            }
                        }

                        public Builder(final _B _parentBuilder, final TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                            this._parentBuilder = _parentBuilder;
                            if (_other!= null) {
                                if (_copy) {
                                    _storedValue = null;
                                    final PropertyTree sourceValuePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sourceValue"));
                                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sourceValuePropertyTree!= null):((sourceValuePropertyTree == null)||(!sourceValuePropertyTree.isLeaf())))) {
                                        this.sourceValue = _other.sourceValue;
                                    }
                                    final PropertyTree targetValuePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("targetValue"));
                                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(targetValuePropertyTree!= null):((targetValuePropertyTree == null)||(!targetValuePropertyTree.isLeaf())))) {
                                        this.targetValue = _other.targetValue;
                                    }
                                    final PropertyTree sourceNamePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("sourceName"));
                                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(sourceNamePropertyTree!= null):((sourceNamePropertyTree == null)||(!sourceNamePropertyTree.isLeaf())))) {
                                        this.sourceName = _other.sourceName;
                                    }
                                    final PropertyTree targetNamePropertyTree = ((_propertyTree == null)?null:_propertyTree.get("targetName"));
                                    if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(targetNamePropertyTree!= null):((targetNamePropertyTree == null)||(!targetNamePropertyTree.isLeaf())))) {
                                        this.targetName = _other.targetName;
                                    }
                                } else {
                                    _storedValue = _other;
                                }
                            } else {
                                _storedValue = null;
                            }
                        }

                        public _B end() {
                            return this._parentBuilder;
                        }

                        protected<_P extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping >_P init(final _P _product) {
                            _product.sourceValue = this.sourceValue;
                            _product.targetValue = this.targetValue;
                            _product.sourceName = this.sourceName;
                            _product.targetName = this.targetName;
                            return _product;
                        }

                        /**
                         * Sets the new value of "sourceValue" (any previous value will be replaced)
                         * 
                         * @param sourceValue
                         *     New value of the "sourceValue" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> withSourceValue(final String sourceValue) {
                            this.sourceValue = sourceValue;
                            return this;
                        }

                        /**
                         * Sets the new value of "targetValue" (any previous value will be replaced)
                         * 
                         * @param targetValue
                         *     New value of the "targetValue" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> withTargetValue(final String targetValue) {
                            this.targetValue = targetValue;
                            return this;
                        }

                        /**
                         * Sets the new value of "sourceName" (any previous value will be replaced)
                         * 
                         * @param sourceName
                         *     New value of the "sourceName" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> withSourceName(final String sourceName) {
                            this.sourceName = sourceName;
                            return this;
                        }

                        /**
                         * Sets the new value of "targetName" (any previous value will be replaced)
                         * 
                         * @param targetName
                         *     New value of the "targetName" property.
                         */
                        public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Builder<_B> withTargetName(final String targetName) {
                            this.targetName = targetName;
                            return this;
                        }

                        @Override
                        public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping build() {
                            if (_storedValue == null) {
                                return this.init(new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping());
                            } else {
                                return ((TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping) _storedValue);
                            }
                        }

                    }

                    public static class Select
                        extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Select, Void>
                    {


                        Select() {
                            super(null, null, null);
                        }

                        public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Select _root() {
                            return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Select();
                        }

                    }

                    public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
                        extends com.kscs.util.jaxb.Selector<TRoot, TParent>
                    {

                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> sourceValue = null;
                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> targetValue = null;
                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> sourceName = null;
                        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> targetName = null;

                        public Selector(final TRoot root, final TParent parent, final String propertyName) {
                            super(root, parent, propertyName);
                        }

                        @Override
                        public Map<String, PropertyTree> buildChildren() {
                            final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                            products.putAll(super.buildChildren());
                            if (this.sourceValue!= null) {
                                products.put("sourceValue", this.sourceValue.init());
                            }
                            if (this.targetValue!= null) {
                                products.put("targetValue", this.targetValue.init());
                            }
                            if (this.sourceName!= null) {
                                products.put("sourceName", this.sourceName.init());
                            }
                            if (this.targetName!= null) {
                                products.put("targetName", this.targetName.init());
                            }
                            return products;
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> sourceValue() {
                            return ((this.sourceValue == null)?this.sourceValue = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>>(this._root, this, "sourceValue"):this.sourceValue);
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> targetValue() {
                            return ((this.targetValue == null)?this.targetValue = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>>(this._root, this, "targetValue"):this.targetValue);
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> sourceName() {
                            return ((this.sourceName == null)?this.sourceName = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>>(this._root, this, "sourceName"):this.sourceName);
                        }

                        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>> targetName() {
                            return ((this.targetName == null)?this.targetName = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TParent>>(this._root, this, "targetName"):this.targetName);
                        }

                    }

                }

                public static class Select
                    extends TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Select, Void>
                {


                    Select() {
                        super(null, null, null);
                    }

                    public static TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Select _root() {
                        return new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Select();
                    }

                }

                public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
                    extends com.kscs.util.jaxb.Selector<TRoot, TParent>
                {

                    private TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TRoot, TParent>> mapping = null;

                    public Selector(final TRoot root, final TParent parent, final String propertyName) {
                        super(root, parent, propertyName);
                    }

                    @Override
                    public Map<String, PropertyTree> buildChildren() {
                        final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                        products.putAll(super.buildChildren());
                        if (this.mapping!= null) {
                            products.put("mapping", this.mapping.init());
                        }
                        return products;
                    }

                    public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TRoot, TParent>> mapping() {
                        return ((this.mapping == null)?this.mapping = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Mapping.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TRoot, TParent>>(this._root, this, "mapping"):this.mapping);
                    }

                }

            }

            public static class Select
                extends TerminologyInference.CodeInference.InferenceDefinition.Selector<TerminologyInference.CodeInference.InferenceDefinition.Select, Void>
            {


                Select() {
                    super(null, null, null);
                }

                public static TerminologyInference.CodeInference.InferenceDefinition.Select _root() {
                    return new TerminologyInference.CodeInference.InferenceDefinition.Select();
                }

            }

            public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
                extends com.kscs.util.jaxb.Selector<TRoot, TParent>
            {

                private TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TParent>> localMappings = null;
                private TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TParent>> externalDefinition = null;

                public Selector(final TRoot root, final TParent parent, final String propertyName) {
                    super(root, parent, propertyName);
                }

                @Override
                public Map<String, PropertyTree> buildChildren() {
                    final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                    products.putAll(super.buildChildren());
                    if (this.localMappings!= null) {
                        products.put("localMappings", this.localMappings.init());
                    }
                    if (this.externalDefinition!= null) {
                        products.put("externalDefinition", this.externalDefinition.init());
                    }
                    return products;
                }

                public TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TParent>> localMappings() {
                    return ((this.localMappings == null)?this.localMappings = new TerminologyInference.CodeInference.InferenceDefinition.LocalMappings.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TParent>>(this._root, this, "localMappings"):this.localMappings);
                }

                public TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TParent>> externalDefinition() {
                    return ((this.externalDefinition == null)?this.externalDefinition = new TerminologyInference.CodeInference.InferenceDefinition.ExternalDefinition.Selector<TRoot, TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TParent>>(this._root, this, "externalDefinition"):this.externalDefinition);
                }

            }

        }

        public static class Select
            extends TerminologyInference.CodeInference.Selector<TerminologyInference.CodeInference.Select, Void>
        {


            Select() {
                super(null, null, null);
            }

            public static TerminologyInference.CodeInference.Select _root() {
                return new TerminologyInference.CodeInference.Select();
            }

        }

        public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
            extends com.kscs.util.jaxb.Selector<TRoot, TParent>
        {

            private Id.Selector<TRoot, TerminologyInference.CodeInference.Selector<TRoot, TParent>> sourceCodeSystem = null;
            private TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TerminologyInference.CodeInference.Selector<TRoot, TParent>> inferenceDefinition = null;

            public Selector(final TRoot root, final TParent parent, final String propertyName) {
                super(root, parent, propertyName);
            }

            @Override
            public Map<String, PropertyTree> buildChildren() {
                final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                products.putAll(super.buildChildren());
                if (this.sourceCodeSystem!= null) {
                    products.put("sourceCodeSystem", this.sourceCodeSystem.init());
                }
                if (this.inferenceDefinition!= null) {
                    products.put("inferenceDefinition", this.inferenceDefinition.init());
                }
                return products;
            }

            public Id.Selector<TRoot, TerminologyInference.CodeInference.Selector<TRoot, TParent>> sourceCodeSystem() {
                return ((this.sourceCodeSystem == null)?this.sourceCodeSystem = new Id.Selector<TRoot, TerminologyInference.CodeInference.Selector<TRoot, TParent>>(this._root, this, "sourceCodeSystem"):this.sourceCodeSystem);
            }

            public TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TerminologyInference.CodeInference.Selector<TRoot, TParent>> inferenceDefinition() {
                return ((this.inferenceDefinition == null)?this.inferenceDefinition = new TerminologyInference.CodeInference.InferenceDefinition.Selector<TRoot, TerminologyInference.CodeInference.Selector<TRoot, TParent>>(this._root, this, "inferenceDefinition"):this.inferenceDefinition);
            }

        }

    }


    /**
     * <p>Java class for anonymous complex type.
     * 
     * <p>The following schema fragment specifies the expected content contained within this class.
     * 
     * <pre>
     * &lt;complexType&gt;
     *   &lt;complexContent&gt;
     *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType"&gt;
     *       &lt;sequence&gt;
     *         &lt;element name="searchCodeSystem" type="{}Id"/&gt;
     *         &lt;element name="codeProperty" type="{}Id"/&gt;
     *         &lt;element name="displayNameProperty" type="{}Id"/&gt;
     *       &lt;/sequence&gt;
     *     &lt;/restriction&gt;
     *   &lt;/complexContent&gt;
     * &lt;/complexType&gt;
     * </pre>
     * 
     * 
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = "", propOrder = {
        "searchCodeSystem",
        "codeProperty",
        "displayNameProperty"
    })
    public static class KeywordInference {

        @XmlElement(required = true)
        protected Id searchCodeSystem;
        @XmlElement(required = true)
        protected Id codeProperty;
        @XmlElement(required = true)
        protected Id displayNameProperty;

        /**
         * Gets the value of the searchCodeSystem property.
         * 
         * @return
         *     possible object is
         *     {@link Id }
         *     
         */
        public Id getSearchCodeSystem() {
            return searchCodeSystem;
        }

        /**
         * Sets the value of the searchCodeSystem property.
         * 
         * @param value
         *     allowed object is
         *     {@link Id }
         *     
         */
        public void setSearchCodeSystem(Id value) {
            this.searchCodeSystem = value;
        }

        /**
         * Gets the value of the codeProperty property.
         * 
         * @return
         *     possible object is
         *     {@link Id }
         *     
         */
        public Id getCodeProperty() {
            return codeProperty;
        }

        /**
         * Sets the value of the codeProperty property.
         * 
         * @param value
         *     allowed object is
         *     {@link Id }
         *     
         */
        public void setCodeProperty(Id value) {
            this.codeProperty = value;
        }

        /**
         * Gets the value of the displayNameProperty property.
         * 
         * @return
         *     possible object is
         *     {@link Id }
         *     
         */
        public Id getDisplayNameProperty() {
            return displayNameProperty;
        }

        /**
         * Sets the value of the displayNameProperty property.
         * 
         * @param value
         *     allowed object is
         *     {@link Id }
         *     
         */
        public void setDisplayNameProperty(Id value) {
            this.displayNameProperty = value;
        }

        /**
         * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
         * 
         * @param _other
         *     A builder instance to which the state of this object will be copied.
         */
        public<_B >void copyTo(final TerminologyInference.KeywordInference.Builder<_B> _other) {
            _other.searchCodeSystem = ((this.searchCodeSystem == null)?null:this.searchCodeSystem.newCopyBuilder(_other));
            _other.codeProperty = ((this.codeProperty == null)?null:this.codeProperty.newCopyBuilder(_other));
            _other.displayNameProperty = ((this.displayNameProperty == null)?null:this.displayNameProperty.newCopyBuilder(_other));
        }

        public<_B >TerminologyInference.KeywordInference.Builder<_B> newCopyBuilder(final _B _parentBuilder) {
            return new TerminologyInference.KeywordInference.Builder<_B>(_parentBuilder, this, true);
        }

        public TerminologyInference.KeywordInference.Builder<Void> newCopyBuilder() {
            return newCopyBuilder(null);
        }

        public static TerminologyInference.KeywordInference.Builder<Void> builder() {
            return new TerminologyInference.KeywordInference.Builder<Void>(null, null, false);
        }

        public static<_B >TerminologyInference.KeywordInference.Builder<_B> copyOf(final TerminologyInference.KeywordInference _other) {
            final TerminologyInference.KeywordInference.Builder<_B> _newBuilder = new TerminologyInference.KeywordInference.Builder<_B>(null, null, false);
            _other.copyTo(_newBuilder);
            return _newBuilder;
        }

        /**
         * Copies all state of this object to a builder. This method is used by the {@link #copyOf} method and should not be called directly by client code.
         * 
         * @param _other
         *     A builder instance to which the state of this object will be copied.
         */
        public<_B >void copyTo(final TerminologyInference.KeywordInference.Builder<_B> _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            final PropertyTree searchCodeSystemPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("searchCodeSystem"));
            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(searchCodeSystemPropertyTree!= null):((searchCodeSystemPropertyTree == null)||(!searchCodeSystemPropertyTree.isLeaf())))) {
                _other.searchCodeSystem = ((this.searchCodeSystem == null)?null:this.searchCodeSystem.newCopyBuilder(_other, searchCodeSystemPropertyTree, _propertyTreeUse));
            }
            final PropertyTree codePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("codeProperty"));
            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(codePropertyPropertyTree!= null):((codePropertyPropertyTree == null)||(!codePropertyPropertyTree.isLeaf())))) {
                _other.codeProperty = ((this.codeProperty == null)?null:this.codeProperty.newCopyBuilder(_other, codePropertyPropertyTree, _propertyTreeUse));
            }
            final PropertyTree displayNamePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("displayNameProperty"));
            if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(displayNamePropertyPropertyTree!= null):((displayNamePropertyPropertyTree == null)||(!displayNamePropertyPropertyTree.isLeaf())))) {
                _other.displayNameProperty = ((this.displayNameProperty == null)?null:this.displayNameProperty.newCopyBuilder(_other, displayNamePropertyPropertyTree, _propertyTreeUse));
            }
        }

        public<_B >TerminologyInference.KeywordInference.Builder<_B> newCopyBuilder(final _B _parentBuilder, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            return new TerminologyInference.KeywordInference.Builder<_B>(_parentBuilder, this, true, _propertyTree, _propertyTreeUse);
        }

        public TerminologyInference.KeywordInference.Builder<Void> newCopyBuilder(final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            return newCopyBuilder(null, _propertyTree, _propertyTreeUse);
        }

        public static<_B >TerminologyInference.KeywordInference.Builder<_B> copyOf(final TerminologyInference.KeywordInference _other, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
            final TerminologyInference.KeywordInference.Builder<_B> _newBuilder = new TerminologyInference.KeywordInference.Builder<_B>(null, null, false);
            _other.copyTo(_newBuilder, _propertyTree, _propertyTreeUse);
            return _newBuilder;
        }

        public static TerminologyInference.KeywordInference.Builder<Void> copyExcept(final TerminologyInference.KeywordInference _other, final PropertyTree _propertyTree) {
            return copyOf(_other, _propertyTree, PropertyTreeUse.EXCLUDE);
        }

        public static TerminologyInference.KeywordInference.Builder<Void> copyOnly(final TerminologyInference.KeywordInference _other, final PropertyTree _propertyTree) {
            return copyOf(_other, _propertyTree, PropertyTreeUse.INCLUDE);
        }

        public static class Builder<_B >implements Buildable
        {

            protected final _B _parentBuilder;
            protected final TerminologyInference.KeywordInference _storedValue;
            private Id.Builder<TerminologyInference.KeywordInference.Builder<_B>> searchCodeSystem;
            private Id.Builder<TerminologyInference.KeywordInference.Builder<_B>> codeProperty;
            private Id.Builder<TerminologyInference.KeywordInference.Builder<_B>> displayNameProperty;

            public Builder(final _B _parentBuilder, final TerminologyInference.KeywordInference _other, final boolean _copy) {
                this._parentBuilder = _parentBuilder;
                if (_other!= null) {
                    if (_copy) {
                        _storedValue = null;
                        this.searchCodeSystem = ((_other.searchCodeSystem == null)?null:_other.searchCodeSystem.newCopyBuilder(this));
                        this.codeProperty = ((_other.codeProperty == null)?null:_other.codeProperty.newCopyBuilder(this));
                        this.displayNameProperty = ((_other.displayNameProperty == null)?null:_other.displayNameProperty.newCopyBuilder(this));
                    } else {
                        _storedValue = _other;
                    }
                } else {
                    _storedValue = null;
                }
            }

            public Builder(final _B _parentBuilder, final TerminologyInference.KeywordInference _other, final boolean _copy, final PropertyTree _propertyTree, final PropertyTreeUse _propertyTreeUse) {
                this._parentBuilder = _parentBuilder;
                if (_other!= null) {
                    if (_copy) {
                        _storedValue = null;
                        final PropertyTree searchCodeSystemPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("searchCodeSystem"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(searchCodeSystemPropertyTree!= null):((searchCodeSystemPropertyTree == null)||(!searchCodeSystemPropertyTree.isLeaf())))) {
                            this.searchCodeSystem = ((_other.searchCodeSystem == null)?null:_other.searchCodeSystem.newCopyBuilder(this, searchCodeSystemPropertyTree, _propertyTreeUse));
                        }
                        final PropertyTree codePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("codeProperty"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(codePropertyPropertyTree!= null):((codePropertyPropertyTree == null)||(!codePropertyPropertyTree.isLeaf())))) {
                            this.codeProperty = ((_other.codeProperty == null)?null:_other.codeProperty.newCopyBuilder(this, codePropertyPropertyTree, _propertyTreeUse));
                        }
                        final PropertyTree displayNamePropertyPropertyTree = ((_propertyTree == null)?null:_propertyTree.get("displayNameProperty"));
                        if (((_propertyTreeUse == PropertyTreeUse.INCLUDE)?(displayNamePropertyPropertyTree!= null):((displayNamePropertyPropertyTree == null)||(!displayNamePropertyPropertyTree.isLeaf())))) {
                            this.displayNameProperty = ((_other.displayNameProperty == null)?null:_other.displayNameProperty.newCopyBuilder(this, displayNamePropertyPropertyTree, _propertyTreeUse));
                        }
                    } else {
                        _storedValue = _other;
                    }
                } else {
                    _storedValue = null;
                }
            }

            public _B end() {
                return this._parentBuilder;
            }

            protected<_P extends TerminologyInference.KeywordInference >_P init(final _P _product) {
                _product.searchCodeSystem = ((this.searchCodeSystem == null)?null:this.searchCodeSystem.build());
                _product.codeProperty = ((this.codeProperty == null)?null:this.codeProperty.build());
                _product.displayNameProperty = ((this.displayNameProperty == null)?null:this.displayNameProperty.build());
                return _product;
            }

            /**
             * Sets the new value of "searchCodeSystem" (any previous value will be replaced)
             * 
             * @param searchCodeSystem
             *     New value of the "searchCodeSystem" property.
             */
            public TerminologyInference.KeywordInference.Builder<_B> withSearchCodeSystem(final Id searchCodeSystem) {
                this.searchCodeSystem = ((searchCodeSystem == null)?null:new Id.Builder<TerminologyInference.KeywordInference.Builder<_B>>(this, searchCodeSystem, false));
                return this;
            }

            /**
             * Returns a new builder to build the value of the "searchCodeSystem" property (replacing previous value).
             * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             * 
             * @return
             *     A new builder to build the value of the "searchCodeSystem" property.
             *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             */
            public Id.Builder<? extends TerminologyInference.KeywordInference.Builder<_B>> withSearchCodeSystem() {
                return this.searchCodeSystem = new Id.Builder<TerminologyInference.KeywordInference.Builder<_B>>(this, null, false);
            }

            /**
             * Sets the new value of "codeProperty" (any previous value will be replaced)
             * 
             * @param codeProperty
             *     New value of the "codeProperty" property.
             */
            public TerminologyInference.KeywordInference.Builder<_B> withCodeProperty(final Id codeProperty) {
                this.codeProperty = ((codeProperty == null)?null:new Id.Builder<TerminologyInference.KeywordInference.Builder<_B>>(this, codeProperty, false));
                return this;
            }

            /**
             * Returns a new builder to build the value of the "codeProperty" property (replacing previous value).
             * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             * 
             * @return
             *     A new builder to build the value of the "codeProperty" property.
             *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             */
            public Id.Builder<? extends TerminologyInference.KeywordInference.Builder<_B>> withCodeProperty() {
                return this.codeProperty = new Id.Builder<TerminologyInference.KeywordInference.Builder<_B>>(this, null, false);
            }

            /**
             * Sets the new value of "displayNameProperty" (any previous value will be replaced)
             * 
             * @param displayNameProperty
             *     New value of the "displayNameProperty" property.
             */
            public TerminologyInference.KeywordInference.Builder<_B> withDisplayNameProperty(final Id displayNameProperty) {
                this.displayNameProperty = ((displayNameProperty == null)?null:new Id.Builder<TerminologyInference.KeywordInference.Builder<_B>>(this, displayNameProperty, false));
                return this;
            }

            /**
             * Returns a new builder to build the value of the "displayNameProperty" property (replacing previous value).
             * Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             * 
             * @return
             *     A new builder to build the value of the "displayNameProperty" property.
             *     Use {@link org.openinfobutton.schemas.kb.Id.Builder#end()} to return to the current builder.
             */
            public Id.Builder<? extends TerminologyInference.KeywordInference.Builder<_B>> withDisplayNameProperty() {
                return this.displayNameProperty = new Id.Builder<TerminologyInference.KeywordInference.Builder<_B>>(this, null, false);
            }

            @Override
            public TerminologyInference.KeywordInference build() {
                if (_storedValue == null) {
                    return this.init(new TerminologyInference.KeywordInference());
                } else {
                    return ((TerminologyInference.KeywordInference) _storedValue);
                }
            }

        }

        public static class Select
            extends TerminologyInference.KeywordInference.Selector<TerminologyInference.KeywordInference.Select, Void>
        {


            Select() {
                super(null, null, null);
            }

            public static TerminologyInference.KeywordInference.Select _root() {
                return new TerminologyInference.KeywordInference.Select();
            }

        }

        public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
            extends com.kscs.util.jaxb.Selector<TRoot, TParent>
        {

            private Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>> searchCodeSystem = null;
            private Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>> codeProperty = null;
            private Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>> displayNameProperty = null;

            public Selector(final TRoot root, final TParent parent, final String propertyName) {
                super(root, parent, propertyName);
            }

            @Override
            public Map<String, PropertyTree> buildChildren() {
                final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
                products.putAll(super.buildChildren());
                if (this.searchCodeSystem!= null) {
                    products.put("searchCodeSystem", this.searchCodeSystem.init());
                }
                if (this.codeProperty!= null) {
                    products.put("codeProperty", this.codeProperty.init());
                }
                if (this.displayNameProperty!= null) {
                    products.put("displayNameProperty", this.displayNameProperty.init());
                }
                return products;
            }

            public Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>> searchCodeSystem() {
                return ((this.searchCodeSystem == null)?this.searchCodeSystem = new Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>>(this._root, this, "searchCodeSystem"):this.searchCodeSystem);
            }

            public Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>> codeProperty() {
                return ((this.codeProperty == null)?this.codeProperty = new Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>>(this._root, this, "codeProperty"):this.codeProperty);
            }

            public Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>> displayNameProperty() {
                return ((this.displayNameProperty == null)?this.displayNameProperty = new Id.Selector<TRoot, TerminologyInference.KeywordInference.Selector<TRoot, TParent>>(this._root, this, "displayNameProperty"):this.displayNameProperty);
            }

        }

    }

    public static class Select
        extends TerminologyInference.Selector<TerminologyInference.Select, Void>
    {


        Select() {
            super(null, null, null);
        }

        public static TerminologyInference.Select _root() {
            return new TerminologyInference.Select();
        }

    }

    public static class Selector<TRoot extends com.kscs.util.jaxb.Selector<TRoot, ?> , TParent >
        extends com.kscs.util.jaxb.Selector<TRoot, TParent>
    {

        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> description = null;
        private Id.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> targetCodeSystem = null;
        private TerminologyInference.CodeInference.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> codeInference = null;
        private TerminologyInference.KeywordInference.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> keywordInference = null;
        private com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> callInferenceByName = null;

        public Selector(final TRoot root, final TParent parent, final String propertyName) {
            super(root, parent, propertyName);
        }

        @Override
        public Map<String, PropertyTree> buildChildren() {
            final Map<String, PropertyTree> products = new HashMap<String, PropertyTree>();
            products.putAll(super.buildChildren());
            if (this.description!= null) {
                products.put("description", this.description.init());
            }
            if (this.targetCodeSystem!= null) {
                products.put("targetCodeSystem", this.targetCodeSystem.init());
            }
            if (this.codeInference!= null) {
                products.put("codeInference", this.codeInference.init());
            }
            if (this.keywordInference!= null) {
                products.put("keywordInference", this.keywordInference.init());
            }
            if (this.callInferenceByName!= null) {
                products.put("callInferenceByName", this.callInferenceByName.init());
            }
            return products;
        }

        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> description() {
            return ((this.description == null)?this.description = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>>(this._root, this, "description"):this.description);
        }

        public Id.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> targetCodeSystem() {
            return ((this.targetCodeSystem == null)?this.targetCodeSystem = new Id.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>>(this._root, this, "targetCodeSystem"):this.targetCodeSystem);
        }

        public TerminologyInference.CodeInference.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> codeInference() {
            return ((this.codeInference == null)?this.codeInference = new TerminologyInference.CodeInference.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>>(this._root, this, "codeInference"):this.codeInference);
        }

        public TerminologyInference.KeywordInference.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> keywordInference() {
            return ((this.keywordInference == null)?this.keywordInference = new TerminologyInference.KeywordInference.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>>(this._root, this, "keywordInference"):this.keywordInference);
        }

        public com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>> callInferenceByName() {
            return ((this.callInferenceByName == null)?this.callInferenceByName = new com.kscs.util.jaxb.Selector<TRoot, TerminologyInference.Selector<TRoot, TParent>>(this._root, this, "callInferenceByName"):this.callInferenceByName);
        }

    }

}
